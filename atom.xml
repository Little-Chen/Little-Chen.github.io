<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chen&#39;s Blog</title>
  
  <subtitle>record</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-23T15:25:06.289Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>陈乾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ajax跨域</title>
    <link href="http://yoursite.com/2018/03/23/Ajax%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/03/23/Ajax跨域/</id>
    <published>2018-03-23T14:11:01.000Z</published>
    <updated>2018-03-23T15:25:06.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h2><ul><li>一般来说，当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面地址不同即为<strong>跨域</strong>。最常见的就是在一个域名下的网页中，调用另一个域名中的资源。</li><li><p>当浏览器报这样的错的时候，就是跨域请求出问题了！</p><!-- ![](http://img.blog.csdn.net/20180224230126966?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl0dGxlX0NoZW5I/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) --><img src="/article_img/跨域报错.png" class="[class names]"><h4 id="从根源上讲，跨域是由浏览器安全的同源策略引起的！"><a href="#从根源上讲，跨域是由浏览器安全的同源策略引起的！" class="headerlink" title="从根源上讲，跨域是由浏览器安全的同源策略引起的！"></a>从根源上讲，跨域是由浏览器安全的同源策略引起的！</h4><a id="more"></a><p><strong>同源策略</strong>是由Netscape提出的著名安全策略，是浏览器最核心、基本的安全功能,它限制了一个源(origin)中加载文本或者脚本与来自其他源(origin)中资源的交互方式。</p><ul><li>所谓的同源就是指的：<strong>协议、域名、端口相同。</strong></li><li>当浏览器执行一个脚本时会<strong>检查是否同源</strong>，只有同源的脚本才会执行，如果不同源即为跨域。<h4 id="同源策略是出于安全考虑"><a href="#同源策略是出于安全考虑" class="headerlink" title="同源策略是出于安全考虑"></a>同源策略是出于安全考虑</h4>对js进行限制，防止恶意用户获取非法数据，同时还防止了大部分XSS攻击（就是向用户界面注入js脚本）。<h4 id="通常跨域是由以下两种同源策略造成的"><a href="#通常跨域是由以下两种同源策略造成的" class="headerlink" title="通常跨域是由以下两种同源策略造成的"></a>通常跨域是由以下两种同源策略造成的</h4></li><li><strong>DOM同源策略。</strong>禁止对不同源的页面的DOM进行操作，主要包括iframe、canvas之类的。不同源的iframe禁止数据交互的，含有不同源数据的canvas会受到污染而无法进行操作。</li><li><strong>XmlHttpRequest同源策略。</strong>简单来说就禁止不同源的AJAX请求。</li></ul></li></ul><hr><h2 id="解决跨域的方法"><a href="#解决跨域的方法" class="headerlink" title="解决跨域的方法"></a>解决跨域的方法</h2><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p>首先，我们需要认知：</p><ol><li><code>jsonp</code>是一种非正式协议。</li><li><code>scrpit</code>的<code>src</code>属性不受同源限制，有跨域请求的能力！（img也不受限制）</li><li><code>jsonp</code>通过script的<code>src</code>属性引入一个js文件，并返回一个js函数的调用！<br><strong>总的来说就是利用了script标签不受同源策略的限制去获取数据。</strong>这就是<code>jsonp</code>的<strong>原理</strong>。<br>具体操作流程为：</li><li>动态创建<code>script</code>标签。</li><li>绑定<code>src</code>路径到想访问的地址。</li><li>添加到<code>document.body.appendChild()</code>中！</li><li>通过函数声明，进行你想进行的数据操作。</li></ol><p><strong>一个简单的jsonp</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fun(data) &#123;  //回调函数</span><br><span class="line">    console.log(data);  //对数据的处理</span><br><span class="line">&#125;;</span><br><span class="line">var body = document.getElementsByTagName(&apos;body&apos;)[0];</span><br><span class="line">var script = document.gerElement(&apos;script&apos;);</span><br><span class="line">script.type = &apos;text/javasctipt&apos;;</span><br><span class="line">script.src = &apos;http://example.com?jsonp=cb&apos;;</span><br><span class="line">body.appendChild(script);</span><br></pre></td></tr></table></figure></p><p>实例：</p><h4 id="百度搜索框！"><a href="#百度搜索框！" class="headerlink" title="百度搜索框！"></a>百度搜索框！</h4><p>以下为搜索关键字<code>wd=apple</code>时</p><blockquote><p><a href="https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=apple&amp;cb=abc" target="_blank" rel="noopener">https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=apple&amp;cb=abc</a></p></blockquote><p>js返回的结构：</p><blockquote><p>abc({q:”apple”,p:false,s:[“apple中国官方网站”,”apple中国”,”apple store官网”,”apple id”,”apple pay”,”apple pay 5折”,”apple watch”,”apple developer”,”apple id注册”,”apple pay如何使用”]});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;Author&quot; content=&quot;FengYu&quot;&gt;</span><br><span class="line">&lt;title&gt;Tz-36期Js&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">* &#123;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">font-family: Microsoft YaHei, serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">li &#123;</span><br><span class="line">list-style: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#box &#123;</span><br><span class="line">width: 400px;</span><br><span class="line">margin: 50px auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">width: 398px;</span><br><span class="line">height: 35px;</span><br><span class="line">border: 1px solid #ddd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul &#123;</span><br><span class="line">width: 398px;</span><br><span class="line">border: 1px solid #666;</span><br><span class="line">cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul li &#123;</span><br><span class="line">line-height: 30px;</span><br><span class="line">text-indent: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul li:hover &#123;</span><br><span class="line">background: #888;</span><br><span class="line">color: #fff;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var Ul = document.getElementsByTagName(&quot;ul&quot;)[0],</span><br><span class="line">input = document.getElementsByTagName(&quot;input&quot;)[0];</span><br><span class="line">//https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&quot;+val+&quot;&amp;cb=abc  百度的js搜索文件</span><br><span class="line">input.oninput = function() &#123;</span><br><span class="line">var val = this.value;</span><br><span class="line">var script = document.createElement(&quot;script&quot;);</span><br><span class="line">script.src = &quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&quot; + val + &quot;&amp;cb=abc&quot;;</span><br><span class="line">document.body.appendChild(script);</span><br><span class="line">script.onload = function() &#123;</span><br><span class="line">document.body.removeChild(this)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function abc(obj) &#123;</span><br><span class="line">var arr = obj.s;</span><br><span class="line">Ul.innerHTML = &quot;&quot;;</span><br><span class="line">for(var i in arr) &#123;</span><br><span class="line">Ul.innerHTML += &apos;&lt;li&gt;&apos; + arr[i] + &apos;&lt;/li&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//事件代理</span><br><span class="line">Ul.onclick = function(e) &#123;</span><br><span class="line">var This = e.target; //事件源</span><br><span class="line">if(/li/i.test(This.nodeName)) &#123;</span><br><span class="line">window.open(&quot;https://www.baidu.com/s?wd=&quot; + This.innerHTML)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p><mark><strong>总结：</strong></mark></p><p>这种方法所有浏览器都兼容，<strong>前端</strong>可以很轻松的做到跨域请求，但也有一些缺点：</p><ul><li>只能通过<strong>GET</strong>方式请求，一方面是参数长度有限制，二是安全性比较差；</li><li>只能通过<strong>js</strong>传回数据！</li><li>后端需要知道前端的<strong>abc</strong>是什么样的结构，主要在<strong>参数</strong>和<strong>回调函数名</strong>,并进行相应配置；</li><li>它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li></ul><h3 id="CORS（跨域资源共享）"><a href="#CORS（跨域资源共享）" class="headerlink" title="CORS（跨域资源共享）"></a>CORS（跨域资源共享）</h3><p>概念：<br><strong>Cross-Origin Resource Sharing(跨域资源共享)</strong>是一个W3C标准，它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p><h4 id="在分析CORS之前，还需要了解一下ajax跨域报错产生的过程。"><a href="#在分析CORS之前，还需要了解一下ajax跨域报错产生的过程。" class="headerlink" title="在分析CORS之前，还需要了解一下ajax跨域报错产生的过程。"></a>在分析CORS之前，还需要了解一下ajax跨域报错产生的过程。</h4><ul><li>使用<strong>XMLHttpRequest发送数据请求</strong>时，浏览器如果发现违反了同源策略（跨域请求资源时）就会自动在请求头（Request Header）中加上一个字段:<code>origin</code>。此字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。</li><li>服务器CORS端会根据这个源的值，判断是否在许可范围，若不符合返回的HTTP响应头（Response Header）信息则会<strong><mark>缺少Access-Control-Allow-Origin项</mark></strong>，从而抛出一个错误。如同文章开头我们看到的那样！</li></ul><p>也就是说，实现CORS通信的关键是服务器。<strong>只要服务器实现了CORS接口，将目标源纳入许可范围，就可以跨源通信。</strong><br>当<code>origin</code>的url值在许可范围内，服务器会返回包含以下头信息字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br></pre></td></tr></table></figure></p><p>随后，浏览器检测到</p><blockquote><p>Access-Control-Allow-Origin 项</p></blockquote><p>就可以允许Ajax进行跨域的访问。<br><strong>简单CORS跨域例子：</strong><br>平时的ajax请求可能是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;POST&quot;, &quot;/damonare&quot;,true);</span><br><span class="line">    xhr.send();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>以上damonare部分是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;￼GET&quot;, &quot;http://segmentfault.com/u/trigkit4/&quot;,true);</span><br><span class="line">    xhr.send();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><mark><strong>总结：</strong></mark></p><ul><li>现代浏览器中和移动端都支持CORS（除了opera mini），<strong>IE下最好10+</strong></li><li>CORS支持所有类型的HTTP请求。</li><li>CORS更为先进和方便，但需要<strong>服务器端</strong>进行处理。</li></ul><h3 id="通过HTML5的postMessage"><a href="#通过HTML5的postMessage" class="headerlink" title="通过HTML5的postMessage"></a>通过HTML5的<code>postMessage</code></h3><p><code>window.postMessage</code>属于html5的新特性</p><ul><li>这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。比如damonare.cn域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信！</li></ul><p><strong>A页面通过postMessage方法发送消息：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() &#123;  </span><br><span class="line">    var ifr = document.getElementById(&apos;ifr&apos;);  </span><br><span class="line">    var targetOrigin = &quot;http://www.google.com&quot;;  </span><br><span class="line">    ifr.contentWindow.postMessage(&apos;hello world!&apos;, targetOrigin);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>postMessage的使用方法：</p><ul><li><code>otherWindow.postMessage(message, targetOrigin);</code><pre><code>- `otherWindow`:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口- `message`:   是要发送的消息，类型为 String、Object (IE8、9 不支持)- `targetOrigin`:   是限定消息接收范围，不限制请使用 `*`</code></pre></li></ul><p><strong>B页面通过message事件监听并接受消息:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var onmessage = function (event) &#123;  </span><br><span class="line">  var data = event.data;//消息  </span><br><span class="line">  var origin = event.origin;//消息来源地址  </span><br><span class="line">  var source = event.source;//源Window对象  </span><br><span class="line">  if(origin==&quot;http://www.baidu.com&quot;)&#123;  </span><br><span class="line">console.log(data);//hello world!  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">if (typeof window.addEventListener != &apos;undefined&apos;) &#123;  </span><br><span class="line">  window.addEventListener(&apos;message&apos;, onmessage, false);  </span><br><span class="line">&#125; else if (typeof window.attachEvent != &apos;undefined&apos;) &#123;  </span><br><span class="line">  //for ie  </span><br><span class="line">  window.attachEvent(&apos;onmessage&apos;, onmessage);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，也可以B页面发送消息，然后A页面监听并接受消息。<br><mark><strong>总结：</strong></mark></p><ul><li><code>postMessage</code>非常适合进行<strong>页面间跨域通信</strong></li><li>需要较高版本的浏览器，IE10+.</li></ul><h3 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h3><p>可以在服务器端设置一个代理，由服务器端向跨域下的网站发出请求，再将请求结果返回给前端，成功避免同源策略的限制。<br>最简单操作，给url加一个前缀即可！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;https://bird.ioliu.cn/v1?url=&apos;+url（请求资源的地址）</span><br></pre></td></tr></table></figure></p><h3 id="通过window-name跨域"><a href="#通过window-name跨域" class="headerlink" title="通过window.name跨域"></a>通过window.name跨域</h3><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。<br>比如：我们在任意一个页面输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.name = &quot;My window&apos;s name&quot;;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    window.location.href = &quot;http://damonare.cn/&quot;;</span><br><span class="line">&#125;,1000)</span><br></pre></td></tr></table></figure><p>进入damonare.cn页面后我们再检测再检测 window.name :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.name; // My window&apos;s name</span><br></pre></td></tr></table></figure></p><p>可以看到，如果在一个标签里面跳转网页的话，我们的 window.name 是不会改变的。</p><p>例子：<br>在 iframe.html 中设置好了 window.name 为我们要传递的字符串。<br>我们在 index.html 中写了下面的代码，可实现跨页面传数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line">var data = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">iframe.onload = function() &#123;</span><br><span class="line">    iframe.onload = function()&#123;</span><br><span class="line">        data = iframe.contentWindow.name;</span><br><span class="line">    &#125;</span><br><span class="line">    iframe.src = &apos;about:blank&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>总结</strong></p><ul><li>此方法适合进行页面间跨域通信！</li></ul><h4 id="最后，还有一种偏门的方法，简单粗暴！"><a href="#最后，还有一种偏门的方法，简单粗暴！" class="headerlink" title="最后，还有一种偏门的方法，简单粗暴！"></a>最后，还有一种偏门的方法，简单粗暴！</h4><!-- ![这里写图片描述](http://img.blog.csdn.net/2018022513095063?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl0dGxlX0NoZW5I/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) --><img src="/article_img/关闭浏览器安全机制.png" class="[class names]"><p>关闭浏览器安全机制，<mark>仅在测试代码时使用。</mark></p><p><strong>解除浏览器安全审核</strong>，可以免去跨域操作,直接进行请求！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome.exe -disable-web-security -user-data-dir</span><br></pre></td></tr></table></figure></p><p>参考文章：<br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享</a><br><a href="https://juejin.im/post/5a0bef0551882554bd509865" target="_blank" rel="noopener">跨域那些事</a><br><a href="https://juejin.im/post/59c132415188256bb018e825" target="_blank" rel="noopener">跨域</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是跨域？&quot;&gt;&lt;a href=&quot;#什么是跨域？&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域？&quot;&gt;&lt;/a&gt;什么是跨域？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一般来说，当一个请求url的&lt;strong&gt;协议、域名、端口&lt;/strong&gt;三者之间任意一个与当前页面地址不同即为&lt;strong&gt;跨域&lt;/strong&gt;。最常见的就是在一个域名下的网页中，调用另一个域名中的资源。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当浏览器报这样的错的时候，就是跨域请求出问题了！&lt;/p&gt;
&lt;!-- ![](http://img.blog.csdn.net/20180224230126966?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl0dGxlX0NoZW5I/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) --&gt;
&lt;img src=&quot;/article_img/跨域报错.png&quot; class=&quot;[class names]&quot;&gt;
&lt;h4 id=&quot;从根源上讲，跨域是由浏览器安全的同源策略引起的！&quot;&gt;&lt;a href=&quot;#从根源上讲，跨域是由浏览器安全的同源策略引起的！&quot; class=&quot;headerlink&quot; title=&quot;从根源上讲，跨域是由浏览器安全的同源策略引起的！&quot;&gt;&lt;/a&gt;从根源上讲，跨域是由浏览器安全的同源策略引起的！&lt;/h4&gt;
    
    </summary>
    
      <category term="Ajax跨域" scheme="http://yoursite.com/categories/Ajax%E8%B7%A8%E5%9F%9F/"/>
    
    
      <category term="Ajax跨域" scheme="http://yoursite.com/tags/Ajax%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP笔记</title>
    <link href="http://yoursite.com/2018/03/23/%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/03/23/图解HTTP笔记/</id>
    <published>2018-03-23T08:02:03.000Z</published>
    <updated>2018-03-23T14:50:17.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="http协议，即超文本传输协议。为TCP-IP的一个子集。"><a href="#http协议，即超文本传输协议。为TCP-IP的一个子集。" class="headerlink" title="http协议，即超文本传输协议。为TCP/IP的一个子集。"></a>http协议，即超文本传输协议。为TCP/IP的一个子集。</h3><ul><li>TCP/IP协议族：包含HTTP协议。</li><li>TCP/IP的分层管理：<ul><li><strong>应用层</strong>：预存了各类应用服务，如：FTP、DNS</li><li><strong>传输层</strong>：提供了计算机间的数据传输，如：TCP、UDP</li><li><strong>网络层</strong>：处理网络上流动的数据包（数据的最小单位）</li><li><strong>数据链路层</strong>：处理网络连接的硬件部分。<a id="more"></a></li></ul></li><li><strong>TCP/IP通信流程</strong><ul><li>发送客户端在应用层发出查看请求，传输层将接受到的数据（请求报文）进行分割，并以此标序后发给网络层。在网络层增加通信目的地的MAC地址后发送给链路层。</li><li>接收端在链路层收到数据，按照序号向上层发送，最终抵达应用层，服务器得到请求。</li></ul></li></ul><h5 id="发送端在每层传输时，都会逐层打上首部信息。接收端则依次删去。-这种数据信息包装的做法叫做封装！"><a href="#发送端在每层传输时，都会逐层打上首部信息。接收端则依次删去。-这种数据信息包装的做法叫做封装！" class="headerlink" title="发送端在每层传输时，都会逐层打上首部信息。接收端则依次删去。  这种数据信息包装的做法叫做封装！"></a>发送端在每层传输时，都会逐层打上<strong>首部</strong>信息。接收端则依次删去。  这种数据信息包装的做法叫做<code>封装</code>！</h5><h3 id="IP、TCP、DNS"><a href="#IP、TCP、DNS" class="headerlink" title="IP、TCP、DNS"></a>IP、TCP、DNS</h3><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><ul><li><strong>IP协议</strong>处在<mark>网络层</mark>，功能是<code>实现数据包的传送</code>。确保数据送达的两个重要条件是： <strong>IP地址和MAC地址</strong>。<ul><li>IP地址：节点被分配到的地址。（可变）</li><li>MAC地址：网卡所属的固定地址。（固定）</li></ul></li><li><strong>ARP</strong>：一种解析地址的协议。可以通过IP地址查询相应MAC地址。<br> <br></li><li>整个通信过程其实经历了很多次随机中转，称为<strong>路由选择</strong>。<br><br><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4></li><li><strong>TCP协议</strong>位于<mark>传输层</mark>，<code>提供字节流服务，确保可靠性</code>。<ul><li>即把大段的数据分割成为有序<strong>报文段</strong>，成为一个个<strong>数据包</strong>进行管理，使传输更<strong>稳定</strong>，可以传输更<strong>大体量</strong>的数据。</li><li>此外，为确保数据送达，TCP协议建立连接进行了<mark>三次握手</mark>。 <ul><li>1.首先发送端发送具有<code>SYN（同步）</code>标志的数据包，表示请求连接。</li><li>2.接受端收到后，回传一个<code>SYN和ACK（确认）</code>的数据包，表示确认收到。</li><li>3.发送端收到后再发送一个标有<code>SYN</code>的数据包，代表“握手结束”，连接已确认建立。<br><br></li></ul></li><li>断开连接进行了<mark>四次握手</mark><ul><li>1.客户端主动关闭连接时，发送一个<code>FIN</code>给服务端，终止连接。</li><li>2.服务端受到后，回传一个<code>ACK（确认）</code>数据包，确认关闭信息。</li><li>3.过一会儿，服务器关闭后，发送一个<code>FIN</code>给客户端表示关闭。</li><li>4.客户端收到<code>FIN</code>给服务器发送<code>ACK</code>，表示确认收到关闭信息。连接中断。</li></ul></li></ul></li></ul><!-- ![Alt text](/article_img/图解HTTP笔记(1).png) --><img src="/article_img/图解HTTP笔记(1).png" class="[class names]"><blockquote><p>SYN：同步序号，是TCP建立连接时使用的握手信号<br>ack：接收端给发送端的一种传输类控制字符，表示发来的数据已确认接收无误<br>FIN：TCP终止时使用的挥手信号</p></blockquote><h4 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h4><ul><li><strong>DNS</strong>位于应用层，是一个<strong>分布式数据库。</strong>提供<strong>域名到IP的解析服务</strong>。<br> DNS协议提供域名查找IP地址，或者逆向查询的服务。<br> <br></li></ul><p>以上参考了文章：<a href="https://blog.csdn.net/the_scent_of_th_soul/article/details/52052495" target="_blank" rel="noopener">TCP连接的建立与终止过程</a></p><h3 id="URL-URI"><a href="#URL-URI" class="headerlink" title="URL/URI"></a>URL/URI</h3><ul><li>URI/URL：   统一资源标识符/统一资源定位符<strong>【URL是URI的子集！】</strong></li><li><strong>URL</strong> ：就是我们常使用的Web浏览器访问页面所要输入的网页地址。</li><li><strong>URI格式:</strong><br><strong>http:// user:pass @<a href="http://www.example.jp:80" target="_blank" rel="noopener">www.example.jp:80</a> /dir/index.htm ?uid=1#ch1</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http://                 ①协议方案名</span><br><span class="line">user:pass               ②登录信息</span><br><span class="line">www.example.jp          ③服务器地址（域名）</span><br><span class="line">80                      ④服务器端口号</span><br><span class="line">dir/index.htm           ⑤文件路径</span><br><span class="line">?uid=1                  ⑥查询字符串</span><br><span class="line">ch1                     ⑦片段标识符</span><br><span class="line">1、3、5是必须属性！</span><br></pre></td></tr></table></figure></li></ul><h2 id="简单的HTTP协议"><a href="#简单的HTTP协议" class="headerlink" title="简单的HTTP协议"></a>简单的HTTP协议</h2><h3 id="HTTP简单通信过程"><a href="#HTTP简单通信过程" class="headerlink" title="HTTP简单通信过程"></a>HTTP简单通信过程</h3><ul><li>请求访问资源的称为<strong>客户端</strong>，提供资源响应的称为<strong>服务端</strong>。</li><li><strong>请求报文</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / index.htm HTTP/<span class="number">1.1</span></span><br><span class="line">Host: hackr.jp</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: <span class="number">16</span></span><br><span class="line"><span class="comment">//空行</span></span><br><span class="line">name = ueno&amp;age=<span class="number">37</span></span><br></pre></td></tr></table></figure></li></ul><p>由请求访问服务器的<code>类型方法</code>，<code>请求资源对象</code>（request-URI），<code>协议版本号</code>，<code>可选请求首部字段</code>和<code>内容实体</code>构成。</p><ul><li><strong>响应报文</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK </span><br><span class="line"><span class="built_in">Date</span>: Tue , <span class="number">10</span> jul <span class="number">2012</span> <span class="number">06</span>:<span class="number">50</span>:<span class="number">15</span> GMT</span><br><span class="line">Content-Length: <span class="number">362</span></span><br><span class="line">Content-Type: text/html</span><br><span class="line"><span class="comment">//空行</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><p>由<code>协议版本</code>，<code>状态码</code>，<code>状态码原因短语</code>，<code>响应首部字段</code>和响应<code>主体</code>构成。</p><h3 id="HTTP是无状态协议"><a href="#HTTP是无状态协议" class="headerlink" title="HTTP是无状态协议"></a>HTTP是无状态协议</h3><ul><li><strong>HTTP是一种无状态协议</strong>：是为了更快速地处理大量事物，减少服务器资源消耗，确保协议可伸缩性而设计的。<br><strong>为了弥补无状态的缺点，引入了Cookie技术。</strong></li><li><p><strong>HTTP请求方法：</strong></p><ul><li>GET：获取资源</li><li>POST：传输实体主体</li><li>PUT：传输文件（不带任何验证机制，不安全）</li><li>HEAD：获取报文首部（通信状态）。</li><li>DELETE：删除文件</li><li>OPTION：询问支持的传输方法</li><li>TRACE：追踪路径</li><li>CONNECT：要求用隧道协议连接代理</li><li>等。。。<blockquote><p>详见参考：http六种 请求方法</p></blockquote></li></ul></li><li><p><strong>建立持久连接</strong>（HTTP keey-alive 或 HTTP connection reuse）保持TCP的状态。</p></li><li><strong>管线化</strong>实现，并行发送多个请求，无需等待。</li><li><strong>Cookie状态管理</strong><ul><li>通过在<strong>请求</strong>和<strong>响应报文</strong>中写入Cookie信息控制客户端状态。</li><li>响应报文返回一个<code>Set-Cookie</code>首部字段信息，保存在客户端。下次请求会自动添加到请求报文中发送。<mark>代码参见书P40</mark></li></ul></li></ul><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p><mark>P43请求行、状态行。</mark></p><p><strong>范围请求：</strong>用首部字段Range指定资源的byte范围。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range： bytes=5001-10000 //请求5001-10000字节的资源</span><br></pre></td></tr></table></figure></p><h2 id="HTTP请求状态码"><a href="#HTTP请求状态码" class="headerlink" title="HTTP请求状态码"></a>HTTP请求状态码</h2><h3 id="1xx-消息"><a href="#1xx-消息" class="headerlink" title="1xx 消息"></a>1xx 消息</h3><p><strong>该类型的状态码代表请求已被接受，需要继续处理。</strong></p><p>100 Continue</p><p>客户端应当继续发送请求，这个临时响应是用来通知客户端的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分。<br>如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</p><p>101 Switching Protocols</p><p>服务器已经理解客户端的请求，并通过 Update 消息头通知客户端采用不同的协议来完成这个请求。只有在切换新的协议更有好处时，才采取类似措施。</p><p>102 Procsessing</p><p>扩展状态码，代表处理将被继续执行。</p><h3 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx 成功"></a>2xx 成功</h3><p>该类型的状态码代表请求已成功被服务器接收、理解并接受。</p><p><strong>200 OK(常用)</strong></p><p>请求成功，请求所希望的响应头或数据体将随此响应返回。</p><p>201 Created</p><p>请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其 URL 已经随 Location 头信息返回。</p><p>202 Accepted</p><p>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。</p><p>203 Non-Authoritative Information</p><p>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。</p><p><strong>204 No Content(常用)</strong></p><p>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。该响应禁止包含任何消息体，始终以消息头后的第一个空行结束。</p><p>205 Reset Content</p><p>服务器成功处理了请求，且没有返回任何内容。与 204 不同之除在于，返回此状态码的响应要求请求者重置文档视图。该响应主要被用于接受用户输入后，<br>立即重置表单，以便用户能够开始另一次输入。同样被禁止包含任何消息体。</p><p><strong>206 Partial Content(常用)</strong></p><p>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或迅雷这类 HTTP 下载工具，都是使用此类响应实现断点续传或将大文件分解为多段同时下载。</p><p>207 Multi-Status</p><p>扩展状态码，代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p><h3 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h3><p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址 ( 重定向目标 )在本次响应的 Location 域中指明。<br>仅当后续请求所使用的方法是 GET 或 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。<br>客户端应当自动检测无限循环重定向，否则会导致双端不必要的资源消耗。HTTP/1.0 版规范建议，浏览器不应超过 5 次重定向。</p><p>300 Multiple Choices</p><p>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息，用户或浏览器能够自行选择一个首选地址进行重定向。<br>除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址列表的实体，以便用户或浏览器从中选择最合适的重定向地址。</p><p><strong>301 Moved Permanently(常用)</strong></p><p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。</p><p><strong>302 Found(常用)</strong></p><p>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。</p><p><strong>303 See other(常用)</strong></p><p>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。该请求禁止被缓存。</p><p><strong>304 Not Modified(常用)</strong></p><p>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容自上次访问或根据请求的条件并没有改变，则服务器应当返回该状态码。<br>304 响应禁止包含消息体。</p><p>305 Use Proxy</p><p>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在 URI 的信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问<br>相应的资源。只有原始服务器才能创建 305 响应。</p><p>306 Switch Proxy</p><p>最新版规范中，已经废弃。</p><p><strong>307 Temporary Redirect(常用)</strong></p><p>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行<br>了指定的情况下，这个响应才是可缓存的。</p><h3 id="4xx客户端错误"><a href="#4xx客户端错误" class="headerlink" title="4xx客户端错误"></a>4xx客户端错误</h3><p>该类型的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。</p><p><strong>400 Bad Request(常用)</strong></p><p>由于<strong>包含语法错误</strong>，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</p><p>401 Unauthorized</p><p>当前请求需要用户验证。</p><p>402 Payment Required</p><p>预留</p><p><strong>403 Forbidden(常用)</strong></p><p>服务器已经理解请求，但是拒绝执行。</p><p><strong>404 Not Found(常用)</strong></p><p>请求失败，请求所希望得到的资源未被在服务器上发现。</p><p>405 Method Not Allowed</p><p>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</p><p>407 Proxy Authentication Required</p><p>与 401 响应类似，只不过客户端必须在代理服务器进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以身份询问。</p><p>408 Request Timeout</p><p>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可买随时再次提交这一请求而无需进行任何更改。</p><p>409 Conflict</p><p>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。</p><p>410 Gone</p><p>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。</p><p>411 Length Required</p><p>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。</p><p>412 Precondition Failed</p><p>服务器在验证请求的头字段中给出先决条件时，没能满足其中的一个或多个。</p><p>413 Request Entity Too Large</p><p>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或能够处理的范围。</p><p>414 Request-URI Too Long</p><p>请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。</p><p>415 Unsupported Media Type</p><p>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器所支持的格式，因此请求被拒绝。</p><p>416 Request Range Not Satisfiable</p><p>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，<br>那么服务器就应当返回 406 状态码。</p><p>417 Expectation Failed</p><p>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</p><p>418 I’m a teapot</p><p>不需要定义，是一个玩笑，为愚人节制定的。</p><p>421 There are too many connections from your internet address</p><p>从当前客户端所在的 IP 地址到服务器的连接数超过了服务器的许可最大范围。通常，这里的 IP 地址指的是从服务器看到的客户端地址。这里的客户端不一定是终端用户。</p><p>422 Unprocessable Entity</p><p>请求格式正确，但是由于含有语义错误，无法响应。</p><p>423 Locked</p><p>当前资源被锁定。</p><p>424 Failed Dependency</p><p>由于之前的某个请求发生的错误，导致当前请求失败。</p><p>425 Unordered Collection</p><p>没正式使用。</p><p>426 Upgraed Required</p><p>客户端应当切换到 TLS/1.0。</p><p>449 Retry With</p><p>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</p><p>451 Unavailable For Legal Reasons</p><p>由 IETF 核准，代表访问因法律的要求被拒绝。</p><h3 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx 服务器错误"></a>5xx 服务器错误</h3><p>该类型的状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。</p><p><strong>500 Internal Server Error(常用)</strong></p><p>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来讲，会出在服务器程序代码出错时出现。</p><p>501 Not Implemented</p><p>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</p><p>502 Bad Gateway</p><p>作为网关或代理工作的服务器尝试执行请求时，从上游服务器收到无效的响应。</p><p><strong>503 Service Unavailable(常用)</strong></p><p>由于临时的服务器维护或过载，服务器当前无法处理请求。</p><p>504 Gateway Timeout</p><p>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器或者辅助服务器收到响应。<br>注意：某些代理服务器在 DNS 查找超时时会返回 400 或者 500 错误。</p><p>505 HTTP Version Not Supported</p><p>服务器不支持，或者拒绝支持在中使用的 HTTP 版本。这暗示着服务器不能或不愿意与客户端相同的版本。</p><p>506 Variant Also Negotiates</p><p>由《透明内容协商协议》扩展，代表服务器存在内部配置错误。</p><p>507 Insufficient Storage</p><p>服务器无法存储完成请求所必须的内容。</p><p>509 Bandwidth Limit Exceeded</p><p>服务器达到带宽限制。这不是一个官方的状态吗，但仍被广泛使用。</p><p>510 Not Extended</p><p>获取资源所需要的策略并没有被满足。</p><h2 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h2><p> 虚拟主机：实现了一台HTTP服务器搭建多个web站点。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;h3 id=&quot;http协议，即超文本传输协议。为TCP-IP的一个子集。&quot;&gt;&lt;a href=&quot;#http协议，即超文本传输协议。为TCP-IP的一个子集。&quot; class=&quot;headerlink&quot; title=&quot;http协议，即超文本传输协议。为TCP/IP的一个子集。&quot;&gt;&lt;/a&gt;http协议，即超文本传输协议。为TCP/IP的一个子集。&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;TCP/IP协议族：包含HTTP协议。&lt;/li&gt;
&lt;li&gt;TCP/IP的分层管理：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用层&lt;/strong&gt;：预存了各类应用服务，如：FTP、DNS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传输层&lt;/strong&gt;：提供了计算机间的数据传输，如：TCP、UDP&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络层&lt;/strong&gt;：处理网络上流动的数据包（数据的最小单位）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据链路层&lt;/strong&gt;：处理网络连接的硬件部分。
    
    </summary>
    
      <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>js的面向对象（OOP）</title>
    <link href="http://yoursite.com/2018/03/23/JS%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88OOP%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/23/JS的面向对象（OOP）/</id>
    <published>2018-03-23T06:31:44.000Z</published>
    <updated>2018-03-23T15:20:12.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</li><li>万事万物皆对象。面向对象的思想主要是以对象为主，将一个问题抽象出具体的对象，并且将抽象出来的对象和对象的属性和方法封装成一个类。</li></ol><h4 id="在-OOP-中，每个对象能够接收消息，处理数据和发送消息给其他对象。每个对象都可以被看作是一个拥有清晰角色或责任的独立小机器。"><a href="#在-OOP-中，每个对象能够接收消息，处理数据和发送消息给其他对象。每个对象都可以被看作是一个拥有清晰角色或责任的独立小机器。" class="headerlink" title="在 OOP 中，每个对象能够接收消息，处理数据和发送消息给其他对象。每个对象都可以被看作是一个拥有清晰角色或责任的独立小机器。"></a>在 OOP 中，每个对象能够接收消息，处理数据和发送消息给其他对象。每个对象都可以被看作是一个拥有清晰角色或责任的独立小机器。</h4><h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><p>我们常提到的两种编程方式就是面向过程和面向对象，面向过程的有C，面向对象的有java、C#、C++、JavaScript等。<br>面向对象和面向过程是两种不同的编程思想。<strong>举个例子形象说明一下：</strong><br><a id="more"></a><br>在面向过程的编程方式中实现“把大象放冰箱”这个问题答案是耳熟能详的，一共分三步：</p><ol><li>开门（冰箱）；</li><li>装进（冰箱，大象）；</li><li>关门（冰箱）。</li></ol><p>而面向对象中呢？</p><ol><li>冰箱.开门（）</li><li>冰箱.装进（大象）</li><li>冰箱.关门（）</li></ol><p><strong>总结：</strong></p><ul><li><strong>面向过程</strong>的特点在于逻辑性强，符合思维方式和解决问题的流程。</li><li><strong>面向对象</strong>的特点就是可扩展性更强一些，解决了代码重用性的问题。<h2 id="为什么要使用面向对象编程？"><a href="#为什么要使用面向对象编程？" class="headerlink" title="为什么要使用面向对象编程？"></a>为什么要使用面向对象编程？</h2>我们知道，js中对象，对象下的方法和属性，都是储存在<strong>内存</strong>中的，调用的时候，是可以随时拿到这些属性和方法的。<h4 id="在编程中使用OOP就是为了提高代码的复用性，而提高代码复用性的根本原因是为了降低内存的使用率。"><a href="#在编程中使用OOP就是为了提高代码的复用性，而提高代码复用性的根本原因是为了降低内存的使用率。" class="headerlink" title="在编程中使用OOP就是为了提高代码的复用性，而提高代码复用性的根本原因是为了降低内存的使用率。"></a>在编程中使用OOP就是为了<strong>提高代码的复用性</strong>，而提高代码复用性的根本原因是为了<mark>降低内存的使用率。</mark></h4><strong>举个简单的例子：</strong><blockquote><p>在同一个家里，只要有一把螺丝刀就可以了，大家都可以使用，而不是每人都配一把螺丝刀，这样没有必要，而且浪费家里的空间。在这个例子中，家就是内存，而每个人就是一个变量，螺丝刀是一个方法，如果很多人想用螺丝刀，那么就创建一个<strong>类</strong>，由这个类创建出多个实例，所有的实例都共用一个螺丝刀，而不是每个人一把螺丝刀，这样太浪费了。</p></blockquote></li></ul><p>面向对象程序设计的<strong>目的</strong>是在编程中促进更好的<strong>灵活性和可维护性</strong>，在大型软件工程中广为流行。即代码各部分相对独立，耦合性低，且功能明确，遇到bug或者更改需求，都可以直接针对特定的对象进行修改，便于维护。<br>另外，面向对象凭借其对<strong>模块化</strong>的重视，面向对象的代码开发更简单，更容易理解，相比非模块化编程方法 , 它能更直接地分析, 编码和理解复杂的情况和过程。 </p><h2 id="面向对象相关术语"><a href="#面向对象相关术语" class="headerlink" title="面向对象相关术语"></a>面向对象相关术语</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ol><li><strong>Namespace 命名空间</strong><br>允许开发人员在一个独特, 应用相关的名字的名称下捆绑所有功能的容器。</li><li><strong>Class 类</strong><br>定义对象的特征。它是对象的属性和方法的模板定义.</li><li><strong>Object 对象</strong><br>类的一个实例。</li><li><strong>Property 属性</strong><br>对象的特征，比如颜色。</li><li><strong>Method 方法</strong><br>对象的能力，比如行走。</li><li><strong>Constructor 构造函数</strong><br>对象初始化的瞬间, 被调用的方法. 通常它的名字与包含它的类一致.</li><li><strong>Inheritance 继承</strong><br>一个类可以继承另一个类的特征。</li><li><strong>Encapsulation 封装</strong><br>一种把数据和相关的方法绑定在一起使用的方法.</li><li><strong>Abstraction 抽象</strong><br>结合复杂的继承，方法，属性的对象能够模拟现实的模型。</li><li><strong>Polymorphism 多态</strong><br>多意为‘许多’，态意为‘形态’。不同类可以定义相同的方法或属性。<h2 id="实现面向对象编程"><a href="#实现面向对象编程" class="headerlink" title="实现面向对象编程"></a>实现面向对象编程</h2><h3 id="面向对象有三大特性，封装、继承和多态"><a href="#面向对象有三大特性，封装、继承和多态" class="headerlink" title="面向对象有三大特性，封装、继承和多态"></a>面向对象有三大特性，封装、继承和多态</h3><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><strong>封装主要实现的功能就是将数据隐藏，只暴露出有限的接口。</strong><br>在js中万物皆对象，字符串、数值、数组、函数都属于Object。因此js基本的创建对象的方法有两种：<ul><li><strong>对象字面量法</strong></li><li><strong>new对象</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//对象字面量</span><br><span class="line">var person = &#123;</span><br><span class="line">name:&quot;chen&quot;,</span><br><span class="line">age：22，</span><br><span class="line">sayname:function ()&#123;</span><br><span class="line">alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//new对象</span><br><span class="line">var person = new Obejct();</span><br><span class="line">person.name = &quot;chen&quot;;</span><br><span class="line">person.age = 22;</span><br><span class="line">person.sayname = function ()&#123;</span><br><span class="line">alert(this.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>但这两种方法都会产生大量重复代码，基于面向对象思想，我们使用新的方式创建对象。</strong></p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式如同它的名字一般，将对象从原料加工、制作、最后出厂，可实现大批量的功能相似产品对象！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name)&#123;</span><br><span class="line">   //1、原料</span><br><span class="line">    var obj=new Object();</span><br><span class="line">   //2、加工</span><br><span class="line">    obj.name=name;</span><br><span class="line">    obj.showName=function()&#123;</span><br><span class="line">       alert(this.name);</span><br><span class="line">    &#125;     </span><br><span class="line">    //3、出场</span><br><span class="line">     return obj; </span><br><span class="line">&#125; </span><br><span class="line">var p1=createPerson(&apos;小米&apos;);</span><br><span class="line">var p1=createPerson(&apos;小红&apos;);</span><br><span class="line">p1.showName();//小米</span><br><span class="line">p2.showName();//小红</span><br></pre></td></tr></table></figure></p><p><strong>工厂模式的优缺点</strong>：虽然解决了创建相似对象的问题，但是却没有解决对象识别问题（即怎样知道一个对象的类型）。</p><h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><p>构造函数其实就是普通的函数，只不过有以下的特点：</p><ul><li><strong>首字母大写</strong>（建议构造函数首字母大写，即使用大驼峰命名，非构造函数首字母小写）</li><li>内部使用this</li><li>使用 new生成实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Dog(name, age, job)&#123;</span><br><span class="line">    this.varieties = varieties;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(varieties, age);</span><br><span class="line">    &#125;;     </span><br><span class="line">&#125;        </span><br><span class="line">var dog1 = new Dog(&quot;Husky&quot;, 2);</span><br><span class="line">var dog2 = new Dog(&quot;Alaska&quot;, 3);</span><br></pre></td></tr></table></figure></li></ul><p><mark>其中new操作符内部会经以下四个步骤：</mark></p><p>1、创建一个新对象；<br>2、将构造函数的作用域赋给新对象（因此这个this就指向这个新对象）；<br>3、执行构造函数中的代码（为这个新对象添加属性）；<br>4、返回新对象。</p><p><strong>构造函数模式的优缺点</strong>：</p><p>　　1、优点：创建自定义函数意味着将来可以将它的实例标识为一种特定的类型，这是构造函数胜过工厂模式的地方<br>　　2、缺点：每个方法都要在每个实例上重新创建一遍</p><h4 id="原型-类-模式"><a href="#原型-类-模式" class="headerlink" title="原型(类)模式"></a>原型(类)模式</h4><h5 id="辨析prtotype、-proto-、constructor"><a href="#辨析prtotype、-proto-、constructor" class="headerlink" title="辨析prtotype、_proto_、constructor"></a>辨析<code>prtotype</code>、<code>_proto_</code>、<code>constructor</code></h5><p>◆<strong>每一个构造函数，都有一个原型[[prototype]]属性       指向构造函数的原型对象</strong><br>◆<strong>每一实例化对象都有一个隐式原型<strong>proto</strong>      指向构造函数的原型对象</strong><br>◆<strong>每一个原型对象都有一个默认的constructor属性，指向对象的构造函数</strong><br><strong>解释</strong>：</p><ul><li>每个函数都有一个 prototype 属性，记住，只有函数才有，对象没有，而每个对象都会拥有一个 <em>proto</em> 属性（后面会对 <em>proto</em> 属性详细讲解）。因为在 JS 中，函数也是对象，所以，函数也会拥有一个 <em>proto</em> 属性。也就是说函数会同时拥有 prototype 和 <em>proto</em> 属性，而对象只有 <em>proot</em> 属性。</li><li>此外，每个由构造函数生成的实例都会拥有的是一个 [[prototype]]的属性，但是规范中并没有明确定义这样一个默认的属性，所以实际上是无法获取这个属性的，不过 FireFox, Safari, Chrome 都会支持通过 <em>proto</em> 来获取这个属性，所以才会有 <em>proto</em> 这样一个属性。也就是说 [[prototype]] == _ _proto__ 。</li><li>构造器作为一个普通函数，如上面所说，会拥有一个 prototype 的属性。这个 prototype 属性是个对象，这个对象就是原型对象（下文说原型对象都指的是这个对象）。原型对象会拥有很多属性和方法，而一旦使用 new 操作符调用构造器函数的时候，所有的实例就会拥有构造器函数的 prototype 属性上的所有属性和方法，也就是原型对象上的所有属性和方法，这样就实现了原型继承。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">// 1. 创建一个构造器</span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line">// 2. 创建一个构造器原型</span><br><span class="line">Person.prototype.name = &apos;jizq&apos;;</span><br><span class="line">Person.prototype.age = 28;</span><br><span class="line">Person.prototype.sayName = function() &#123;</span><br><span class="line">console.log(this.name)</span><br><span class="line">&#125;;</span><br><span class="line">// 3. 由构造器创建两个实例</span><br><span class="line">var p1 = new Person(),</span><br><span class="line">p2 = new Person();</span><br><span class="line">p1.sayName(); // jizq</span><br><span class="line">p2.sayName(); // jizq</span><br><span class="line"></span><br><span class="line">// 4. 查看这两个实例之间的关系</span><br><span class="line">console.log(p1.sayName == p2.sayName); // true</span><br><span class="line">// Problems with prototypes</span><br><span class="line">// 当一个属性包含的是一个引用值的时候，使用 prototype 会出现问题。例如：</span><br><span class="line">Person.prototype.friends = [&apos;Shelby&apos;, &apos;Court&apos;];</span><br><span class="line">p1.friends.push(&apos;Van&apos;);</span><br><span class="line">console.log(p2.friends); // [&apos;Shelby&apos;, &apos;Court&apos;, &apos;Van&apos;]</span><br><span class="line">// 因为 friends 这个属性并不是存在在 p1 上，而是存在于 Person.prototype 上面。通常，实例需要拥有自己的属性。</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>p1.sayName 和 p2.sayName 是同一个 sayName。当通过 Person.prototype 来修改 sayName 属性的时候，<strong>所有的实例都会受到影响</strong>，因为所有的实例都是指向这个方法的。<br>下图为网上最经典的原型链的图解：<br><img src="http://img.blog.csdn.net/20180301220711921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl0dGxlX0NoZW5I/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>原型模式的优缺点：</strong></p><p>　　1、优点：可以让所有的对象实例共享它所包含的属性和方法</p><p>　　2、缺点：原型中是所有属性都是<strong>共享</strong>的，但是实例一般都是要有自己的单独属性的。所以一般很少单独使用原型模式。</p><h4 id="混合模式（常用作封装类）"><a href="#混合模式（常用作封装类）" class="headerlink" title="混合模式（常用作封装类）"></a>混合模式（常用作封装类）</h4><p>通过<mark>构造函数模式定义实例（私有）属性，而原型模式用于定义方法和共享的属性</mark></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Person (name,age)&#123;//定义私有属性</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayname = function ()&#123;//定义公有属性</span><br><span class="line">console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;chen&quot;,22);</span><br><span class="line">var person2 = new Person(&quot;qian&quot;,21);</span><br><span class="line">console.log(person1.age);//22</span><br><span class="line">console.log(person2.age);//21</span><br><span class="line">person1.sayname()//chen</span><br><span class="line">person2.sayname()//qian</span><br><span class="line">console.log(person1.sayname===person2.sayname);//true</span><br><span class="line">person1.age = 26;</span><br><span class="line">//改变person1的属性和方法</span><br><span class="line">person1.sayname = function ()&#123;console.log(&quot;change&quot;)&#125;;</span><br><span class="line">console.log(person1.age);//26     </span><br><span class="line">console.log(person2.age);//21  person2不受影响</span><br><span class="line">person1.sayname()//change</span><br><span class="line">person2.sayname()//qian  person2访问原型的方法，不受影响</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="类式继承（原型继承）"><a href="#类式继承（原型继承）" class="headerlink" title="类式继承（原型继承）"></a>类式继承（原型继承）</h4><p>所谓的类式继承就是使用的原型的方式，将方法添加在父类的原型上，然后子类的原型是父类的一个实例化对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line"> this.name=name;</span><br><span class="line"> this.className=&quot;person&quot; </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getClassName=function()&#123;</span><br><span class="line"> console.log(this.className)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Man()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Man.prototype=new Person();//1</span><br><span class="line">//Man.prototype=new Person(&quot;Davin&quot;);//2</span><br><span class="line">var man=new Man;</span><br><span class="line">&gt;man.getClassName()</span><br><span class="line">&gt;&quot;person&quot;</span><br><span class="line">&gt;man instanceof Person</span><br><span class="line">&gt;true</span><br></pre></td></tr></table></figure></p><p>其中最核心的一句代码是<code>Man.prototype=new Person() ;</code><br>这种继承方式下，所有的子类实例会共享一个父类对象的实例，这种方案最大问题就是子类无法通过父类创建私有属性。比如每一个Person都有一个名字，我们在初始化每个Man的时候要指定一个不同名字，然后子类将这个名字传递给父类，对于每个man来说，保存在相应person中的name应该是不同的，但是这种方式根本做不到。<strong>所以，这种继承方式，实战中基本不用！</strong></p><h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line"> this.name=name;</span><br><span class="line"> this.className=&quot;person&quot; </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName=function()&#123;</span><br><span class="line"> console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">function Man(name)&#123;</span><br><span class="line">  Person.apply(this,arguments)</span><br><span class="line">&#125;</span><br><span class="line">var man1=new Man(&quot;Davin&quot;);</span><br><span class="line">var man2=new Man(&quot;Jack&quot;);</span><br><span class="line">&gt;man1.name</span><br><span class="line">&gt;&quot;Davin&quot;</span><br><span class="line">&gt;man2.name</span><br><span class="line">&gt;&quot;Jack&quot;</span><br><span class="line">&gt;man1.getName() //1 报错</span><br><span class="line">&gt;man1 instanceof Person</span><br><span class="line">&gt;true</span><br></pre></td></tr></table></figure><p><code>Person.apply(this,arguments)</code>：子类的在构造函数里用子类实例的this去调用父类的构造函数，从而达到继承父类属性的效果。<br>这样一来，每new一个子类的实例，构造函数执行完后，都会有自己的一份资源(name)，不过会造成    内存浪费。但是这种办法只能继承父类构造函数中声明的实例属性，并没有继承父类原型的属性和方法，所以就找不到getName方法，所以1处会报错。为了同时继承父类原型，从而诞生了组合继承的方式:</p><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line"> this.name=name||&quot;default name&quot;; //1</span><br><span class="line"> this.className=&quot;person&quot; </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName=function()&#123;</span><br><span class="line"> console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">function Man(name)&#123;</span><br><span class="line">  Person.apply(this,arguments)</span><br><span class="line">&#125;</span><br><span class="line">//继承原型</span><br><span class="line">Man.prototype = new Person();</span><br><span class="line">var man1=new Man(&quot;Davin&quot;);</span><br><span class="line">&gt; man1.name</span><br><span class="line">&gt;&quot;Davin&quot;</span><br><span class="line">&gt; man1.getName()</span><br><span class="line">&gt;&quot;Davin&quot;</span><br></pre></td></tr></table></figure><p>组合式继承就是汲取两者的优点，即避免了内存浪费，又使得每个实例化的子类互不影响。</p><h4 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h4><p>组合式继承的方法固然好，但是会导致一个问题，父类的构造函数会被创建两次（call()，apply()的时候一遍，new的时候又一遍），所以为了解决这个问题，又出现了<strong>寄生组合继承</strong>。</p><p>也就是说，我们只需要先给父类的原型创建一个副本，然后修改子类constructor属性，最后在设置子类的原型就可以了！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line"> this.name=name; //1</span><br><span class="line"> this.className=&quot;person&quot; </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName=function()&#123;</span><br><span class="line"> console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">function Man(name)&#123;</span><br><span class="line">  Person.apply(this,arguments)</span><br><span class="line">&#125;</span><br><span class="line">//注意此处</span><br><span class="line">Man.prototype = Object.create(Person.prototype);</span><br><span class="line">var man1=new Man(&quot;Davin&quot;);</span><br><span class="line">&gt; man1.name</span><br><span class="line">&gt;&quot;Davin&quot;</span><br><span class="line">&gt; man1.getName()</span><br><span class="line">&gt;&quot;Davin&quot;</span><br></pre></td></tr></table></figure></p><p>这里用到了<code>Object.creat(obj)</code>方法，该方法会对传入的obj对象进行浅拷贝。和上面组合继承的主要区别就是：将父类的原型复制给了子类原型。这种做法很清晰：</p><ul><li>构造函数中继承父类属性／方法，并初始化父类。</li><li>子类原型和父类原型建立联系。</li></ul><p>另外我们发现，Person和Man实例的constructor指向都是Person，当然，这并不会改变instanceof的结果，但是对于需要用到construcor的场景，就会有问题。所以一般我们会加上这么一句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Man.prototype.constructor = Man</span><br></pre></td></tr></table></figure></p><p><strong><mark>综合来看，es5下，这种方式是首选，也是实际上最流行的。</mark></strong></p><h4 id="ES6-中的-class继承"><a href="#ES6-中的-class继承" class="headerlink" title="ES6 中的 class继承"></a>ES6 中的 class继承</h4><p>es6引入了class、extends、super、static<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  //static sCount=0 //1</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">     this.name=name; </span><br><span class="line">     this.sCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  //实例方法 //2</span><br><span class="line">  getName()&#123;</span><br><span class="line">   console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">  static sTest()&#123;</span><br><span class="line">    console.log(&quot;static method test&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Man extends Person&#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    super(name)//3</span><br><span class="line">    this.sex=&quot;male&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var man=new Man(&quot;Davin&quot;)</span><br><span class="line">man.getName()</span><br><span class="line">//man.sTest()</span><br><span class="line">Man.sTest()//4</span><br><span class="line">输出结果：</span><br><span class="line">Davin</span><br><span class="line">static method test</span><br></pre></td></tr></table></figure></p><p>最后再说一下 ES6 中 class 实现原型继承。ES6 中 class 其实是原型继承的语法糖而已！<br><strong>es6继承的不足</strong>:</p><ul><li>不支持静态属性（除函数）。</li><li>class中不能定义私有变量和函数。class中定义的所有函数都会被放倒原型当中，都会被子类继承，而属性都会作为实例属性挂到this上。如果子类想定义一个私有的方法或定义一个private 变量，便不能直接在class花括号内定义，这真的很不方便！<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><strong>多态</strong>（Polymorphism）按字面的意思就是“多种状态”,在面向对象语言中，接口的多种不同的实现方式即为多态。<br><strong>可以解释为：</strong>同样的操作作用于不同对象上面，可以产生不同的解释和不同的运行结果。换句话说，，给不同对象发送统一消息的时候，这些对象会根据这个信息分别给出不同的反馈。<br>下面看一个例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line"> this.name=name</span><br><span class="line"> this.age=age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.toString=function()&#123;</span><br><span class="line"> return &quot;I am a Person, my name is &quot;+ this.name</span><br><span class="line">&#125;</span><br><span class="line">function Man(name,age)&#123;</span><br><span class="line">  Person.apply(this,arguments)</span><br><span class="line">&#125;</span><br><span class="line">Man.prototype = Object.create(Person.prototype);</span><br><span class="line">Man.prototype.toString=function()&#123;</span><br><span class="line">  return &quot;I am a Man, my name is&quot;+this.name;</span><br><span class="line">&#125;</span><br><span class="line">var person=new Person(&quot;Neo&quot;,19)</span><br><span class="line">var man1=new Man(&quot;Davin&quot;,18)</span><br><span class="line">var man2=new Man(&quot;Jack&quot;,19)</span><br><span class="line">&gt; person+&quot;&quot;</span><br><span class="line">&gt; &quot;I am a Person, my name is Neo&quot;</span><br><span class="line">&gt; man1+&quot;&quot;</span><br><span class="line">&gt; &quot;I am a Man, my name isDavin&quot;</span><br><span class="line">&gt; man1 false</span><br></pre></td></tr></table></figure></li></ul><p>总的来说，JavaScript的多态的思想实际上就是把“做什么”和“谁去做”分离开来，要实现这一点，归根结底就是解耦。</p><h2 id="OOP-的典型案例"><a href="#OOP-的典型案例" class="headerlink" title="OOP 的典型案例"></a>OOP 的典型案例</h2><h3 id="实现一个js插件"><a href="#实现一个js插件" class="headerlink" title="实现一个js插件"></a>实现一个js插件</h3><p>见另一篇文章：</p><p>参考文章：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript" target="_blank" rel="noopener">MDN面向对象</a><br><a href="https://www.cnblogs.com/yuxingyoucan/p/5797142.html" target="_blank" rel="noopener">JS中面向对象</a><br><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="noopener">阮一峰js面向对象</a><br><a href="https://github.com/oakland/Native-JS-Practice/blob/master/11-learnOOPfromCircles.js/9-%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3JS%E4%B8%AD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%85%A8-%E5%A4%87%E4%BB%BD%E7%94%A8%EF%BC%89.md" target="_blank" rel="noopener">github 理解面向对象</a><br><a href="https://juejin.im/post/59396c96fe88c2006afc2707" target="_blank" rel="noopener">面向对象编程</a>（最系统）<br><a href="https://juejin.im/entry/58253c3fd2030900552ddba8" target="_blank" rel="noopener">JavaScript继承与多态</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是面向对象？&quot;&gt;&lt;a href=&quot;#什么是面向对象？&quot; class=&quot;headerlink&quot; title=&quot;什么是面向对象？&quot;&gt;&lt;/a&gt;什么是面向对象？&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。&lt;/li&gt;
&lt;li&gt;万事万物皆对象。面向对象的思想主要是以对象为主，将一个问题抽象出具体的对象，并且将抽象出来的对象和对象的属性和方法封装成一个类。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;在-OOP-中，每个对象能够接收消息，处理数据和发送消息给其他对象。每个对象都可以被看作是一个拥有清晰角色或责任的独立小机器。&quot;&gt;&lt;a href=&quot;#在-OOP-中，每个对象能够接收消息，处理数据和发送消息给其他对象。每个对象都可以被看作是一个拥有清晰角色或责任的独立小机器。&quot; class=&quot;headerlink&quot; title=&quot;在 OOP 中，每个对象能够接收消息，处理数据和发送消息给其他对象。每个对象都可以被看作是一个拥有清晰角色或责任的独立小机器。&quot;&gt;&lt;/a&gt;在 OOP 中，每个对象能够接收消息，处理数据和发送消息给其他对象。每个对象都可以被看作是一个拥有清晰角色或责任的独立小机器。&lt;/h4&gt;&lt;h3 id=&quot;面向对象和面向过程的区别？&quot;&gt;&lt;a href=&quot;#面向对象和面向过程的区别？&quot; class=&quot;headerlink&quot; title=&quot;面向对象和面向过程的区别？&quot;&gt;&lt;/a&gt;面向对象和面向过程的区别？&lt;/h3&gt;&lt;p&gt;我们常提到的两种编程方式就是面向过程和面向对象，面向过程的有C，面向对象的有java、C#、C++、JavaScript等。&lt;br&gt;面向对象和面向过程是两种不同的编程思想。&lt;strong&gt;举个例子形象说明一下：&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="面向对象" scheme="http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>call，apply，bind改变this指向</title>
    <link href="http://yoursite.com/2018/03/22/call%EF%BC%8Capply%EF%BC%8Cbind%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91/"/>
    <id>http://yoursite.com/2018/03/22/call，apply，bind改变this指向/</id>
    <published>2018-03-22T09:32:53.000Z</published>
    <updated>2018-03-23T15:19:59.981Z</updated>
    
    <content type="html"><![CDATA[<p><strong>推荐非常浅显易懂的一片文章，搭配代码实例，易于理解！</strong><a href="https://juejin.im/post/59bfe84351882531b730bac2" target="_blank" rel="noopener">this与call…</a></p><p>首先我们先要明确一点：</p><h3 id="this-永远指向最后调用它的那个对象！！！"><a href="#this-永远指向最后调用它的那个对象！！！" class="headerlink" title="this 永远指向最后调用它的那个对象！！！"></a><strong>this 永远指向最后调用它的那个对象！！！</strong></h3><p>然后我们在看看这三种方法的异同：</p><ol><li><code>call()</code>主动执行，第一个参数为this要指向的对象，函数执行需要的实参依次写在后面。</li><li><code>apply()</code>主动执行，第一个参数为this要指向的对象，第二参数为一个数组(类数组)，数组里包含所有实参。</li><li><code>bind()</code>也用来改变this的指向，但不会主动执行函数。传参方式同call。<strong>但是bind不兼容IE8</strong></li><li>三种方法，当第一个参数传<code>null</code>或者<code>空</code>，<code>undefined</code>时，this均指向<code>window</code>。<a id="more"></a><h3 id="apply："><a href="#apply：" class="headerlink" title="apply："></a>apply：</h3></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a =&#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    fn : function (a,b) &#123;</span><br><span class="line">        console.log( a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = a.fn;</span><br><span class="line">b.apply(a,[1,2])     // 3</span><br></pre></td></tr></table></figure><h3 id="call："><a href="#call：" class="headerlink" title="call："></a>call：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a =&#123;</span><br><span class="line">        name : &quot;Cherry&quot;,</span><br><span class="line">        fn : function (a,b) &#123;</span><br><span class="line">            console.log( a + b)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var b = a.fn;</span><br><span class="line">    b.call(a,1,2)       // 3</span><br></pre></td></tr></table></figure><h3 id="bind："><a href="#bind：" class="headerlink" title="bind："></a>bind：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a =&#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    fn : function (a,b) &#123;</span><br><span class="line">        console.log( a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = a.fn;</span><br><span class="line">b.bind(a,1,2)()           // 3</span><br></pre></td></tr></table></figure><h3 id="常见的用法："><a href="#常见的用法：" class="headerlink" title="常见的用法："></a>常见的用法：</h3><ul><li><p>改变this指向，引入其他对象的<strong>方法、属性</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  showName: function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&apos;qianlong&apos;);</span><br><span class="line">person.showName();</span><br><span class="line"></span><br><span class="line">var animal = &#123;</span><br><span class="line">  name: &apos;cat&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1 call</span><br><span class="line">person.showName.call(animal);</span><br><span class="line">// 2 apply</span><br><span class="line">person.showName.apply(animal);</span><br><span class="line">// 3 bind</span><br><span class="line">person.showName.bind(animal)();</span><br><span class="line">//均输出cat</span><br></pre></td></tr></table></figure></li><li><p>转化函数的<code>arguments</code>为真正的数组。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [].slice.apply(arguments)  //可以将函数的参数类数组改变为数组形式，方便调用。</span><br></pre></td></tr></table></figure><p><strong>其余应用可参考<a href="https://qianlongo.github.io/2016/04/26/js%E4%B8%ADcall%E3%80%81apply%E3%80%81bind%E9%82%A3%E4%BA%9B%E4%BA%8B/#more" target="_blank" rel="noopener">此文章的应用部分</a></strong><br>包括：</p><ul><li>求数组最大和最小值</li><li>伪数组转化为数组</li><li>数组追加</li><li>使用call、apply继承其他类的方法（推荐）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;推荐非常浅显易懂的一片文章，搭配代码实例，易于理解！&lt;/strong&gt;&lt;a href=&quot;https://juejin.im/post/59bfe84351882531b730bac2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;this与call…&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先我们先要明确一点：&lt;/p&gt;
&lt;h3 id=&quot;this-永远指向最后调用它的那个对象！！！&quot;&gt;&lt;a href=&quot;#this-永远指向最后调用它的那个对象！！！&quot; class=&quot;headerlink&quot; title=&quot;this 永远指向最后调用它的那个对象！！！&quot;&gt;&lt;/a&gt;&lt;strong&gt;this 永远指向最后调用它的那个对象！！！&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;然后我们在看看这三种方法的异同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;call()&lt;/code&gt;主动执行，第一个参数为this要指向的对象，函数执行需要的实参依次写在后面。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apply()&lt;/code&gt;主动执行，第一个参数为this要指向的对象，第二参数为一个数组(类数组)，数组里包含所有实参。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind()&lt;/code&gt;也用来改变this的指向，但不会主动执行函数。传参方式同call。&lt;strong&gt;但是bind不兼容IE8&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;三种方法，当第一个参数传&lt;code&gt;null&lt;/code&gt;或者&lt;code&gt;空&lt;/code&gt;，&lt;code&gt;undefined&lt;/code&gt;时，this均指向&lt;code&gt;window&lt;/code&gt;。
    
    </summary>
    
      <category term="JS核心" scheme="http://yoursite.com/categories/JS%E6%A0%B8%E5%BF%83/"/>
    
    
      <category term="JS核心" scheme="http://yoursite.com/tags/JS%E6%A0%B8%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化</title>
    <link href="http://yoursite.com/2018/03/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/03/21/前端性能优化/</id>
    <published>2018-03-21T03:02:44.000Z</published>
    <updated>2018-03-23T15:19:47.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端性能优化的常用方法"><a href="#前端性能优化的常用方法" class="headerlink" title="前端性能优化的常用方法"></a>前端性能优化的常用方法</h2><h4 id="减少HTTP请求个数"><a href="#减少HTTP请求个数" class="headerlink" title="减少HTTP请求个数"></a>减少HTTP请求个数</h4><p>整合图片，合并css及JS文件，或者采用lazyload技术进行优化。</p><h4 id="避免repaint-和reflow"><a href="#避免repaint-和reflow" class="headerlink" title="避免repaint 和reflow"></a>避免repaint 和reflow</h4><p>重绘：元素样式改变，布局未变，不影响DOM结构。<br>重排：DOM部分重新渲染。</p><p>解决办法：避免操作DOM的结构、尺寸和内容；或者对于需要频繁操作的元素采用absolute定位脱离文档层。<br><a id="more"></a></p><h4 id="减少DOM的操作次数，整合多次DOM操作，尽量降低次数。"><a href="#减少DOM的操作次数，整合多次DOM操作，尽量降低次数。" class="headerlink" title="减少DOM的操作次数，整合多次DOM操作，尽量降低次数。"></a>减少DOM的操作次数，整合多次DOM操作，尽量降低次数。</h4><p>避免循环操作DOM，性能开销太大。</p><h4 id="JSON进行数据交互，体量小，无需特殊处理货工具包。"><a href="#JSON进行数据交互，体量小，无需特殊处理货工具包。" class="headerlink" title="JSON进行数据交互，体量小，无需特殊处理货工具包。"></a>JSON进行数据交互，体量小，无需特殊处理货工具包。</h4><h4 id="使用CDN（内容分发网络）"><a href="#使用CDN（内容分发网络）" class="headerlink" title="使用CDN（内容分发网络）"></a>使用CDN（内容分发网络）</h4><p>基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上</p><h4 id="压缩图片和图片精灵"><a href="#压缩图片和图片精灵" class="headerlink" title="压缩图片和图片精灵"></a>压缩图片和图片精灵</h4><h4 id="使用浏览器缓存静态资源"><a href="#使用浏览器缓存静态资源" class="headerlink" title="使用浏览器缓存静态资源"></a>使用浏览器缓存静态资源</h4><p>cache-control，设定缓存，expires设定缓存时间。</p><p>###CSS为什么要放在头，而JS放在尾？<br>浏览器在执行JavaScript代码时，不能同时做其它事情，即每次出现都会让页面等待脚本的解析和执行（不论JavaScript是内嵌的还是外链的），JavaScript代码执行完成后，才继续渲染页面。这个也就是JavaScript的阻塞特性。</p><p>现在浏览器为了更好的用户体验，渲染引擎会尝试尽快在屏幕上显示内容，它不会等到所有的HTMl元素解析之后在构建和布局dom树，所以部分内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。<br>因此CSS放在头部可以有效减少白屏时间和存在的跳闪现象。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前端性能优化的常用方法&quot;&gt;&lt;a href=&quot;#前端性能优化的常用方法&quot; class=&quot;headerlink&quot; title=&quot;前端性能优化的常用方法&quot;&gt;&lt;/a&gt;前端性能优化的常用方法&lt;/h2&gt;&lt;h4 id=&quot;减少HTTP请求个数&quot;&gt;&lt;a href=&quot;#减少HTTP请求个数&quot; class=&quot;headerlink&quot; title=&quot;减少HTTP请求个数&quot;&gt;&lt;/a&gt;减少HTTP请求个数&lt;/h4&gt;&lt;p&gt;整合图片，合并css及JS文件，或者采用lazyload技术进行优化。&lt;/p&gt;
&lt;h4 id=&quot;避免repaint-和reflow&quot;&gt;&lt;a href=&quot;#避免repaint-和reflow&quot; class=&quot;headerlink&quot; title=&quot;避免repaint 和reflow&quot;&gt;&lt;/a&gt;避免repaint 和reflow&lt;/h4&gt;&lt;p&gt;重绘：元素样式改变，布局未变，不影响DOM结构。&lt;br&gt;重排：DOM部分重新渲染。&lt;/p&gt;
&lt;p&gt;解决办法：避免操作DOM的结构、尺寸和内容；或者对于需要频繁操作的元素采用absolute定位脱离文档层。&lt;br&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JS迭代器与循环</title>
    <link href="http://yoursite.com/2018/03/19/JS%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2018/03/19/JS迭代器与循环/</id>
    <published>2018-03-19T11:02:03.000Z</published>
    <updated>2018-03-23T08:27:31.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="map、eval、for…in、for…of、forEach"><a href="#map、eval、for…in、for…of、forEach" class="headerlink" title="map、eval、for…in、for…of、forEach"></a>map、eval、for…in、for…of、forEach</h2><h3 id="最早的数组遍历方式"><a href="#最早的数组遍历方式" class="headerlink" title="最早的数组遍历方式"></a>最早的数组遍历方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> index = <span class="number">0</span>;index &lt; a.length;index++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="map定义和方法"><a href="#map定义和方法" class="headerlink" title="map定义和方法"></a>map定义和方法</h3><p><strong>map</strong>理解为“映射”的意思，基本用法同forEach，为ES5新增属性方法。<br>❤<strong>map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理的后值。</strong><br>❤<strong>map()方法按照原始数组元素顺序依次处理元素。</strong> </p><p><strong>注意：</strong><br>map不会对空数组进行检测<br>map不会改变原始数组<br>处理函数必须有<strong>返回值</strong>，否则会映射成undefined。<br><strong>map使用语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue，index，arr</span>),<span class="title">thisValue</span>)</span></span><br></pre></td></tr></table></figure><p>参数:</p><ol><li>处理函数（必须），下属参数依次为：当前值value，序号index，原数组arr。</li><li>thisValue(可选)</li></ol><p>❤另外，由于map方法为ES5新增方法，不支持<strong>IE9以下浏览器</strong>。如果需要兼容，可用<strong>原型扩展</strong>。<br>方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.map != <span class="string">"function"</span>) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, length = <span class="keyword">this</span>.length; k &lt; length; k++) &#123;      </span><br><span class="line">         arr.push(fn.call(context, <span class="keyword">this</span>[k], k, <span class="keyword">this</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jquery中map方法用法同原生"><a href="#jquery中map方法用法同原生" class="headerlink" title="jquery中map方法用法同原生"></a>jquery中map方法用法同原生</h4><p>且从 1.6 开始，该函数也支持遍历对象。它接受两个参数，分别是要处理的数组/对象和处理函数，其处理函数也接受键值和键名两个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**** jQuery $.map() ****/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选数组元素</span></span><br><span class="line"><span class="keyword">var</span> arrTmp = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> bigNum = $.map(arrTmp,<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// bigNum -&gt; [3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理对象</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    jack:&#123;<span class="attr">age</span>:<span class="number">9</span>&#125;,</span><br><span class="line">    tom:&#123;<span class="attr">age</span>:<span class="number">20</span>&#125;,</span><br><span class="line">    bobo:&#123;<span class="attr">age</span>:<span class="number">30</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oldMan = $.map(person,<span class="function"><span class="keyword">function</span>(<span class="params">value,key</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(value.age&gt;<span class="number">26</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// oldMan -&gt; ["bobo"]</span></span><br></pre></td></tr></table></figure><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><blockquote><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。</p></blockquote><p>注意：<br><strong>strong text</strong>该方法只接受原始字符串作为参数，如果 string 参数不是原始字符串，那么该方法将不作任何改变地返回。<br>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"x=10;y=20;document.write(x*y)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="built_in">eval</span>(<span class="string">"2+2"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x=<span class="number">10</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="built_in">eval</span>(x+<span class="number">17</span>))</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p> ###1 forEach<br>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, array</span>) </span>&#123; <span class="comment">// ... &#125;);</span></span><br></pre></td></tr></table></figure><p>forEach遍历数组，而不是遍历对象哦，而且在遍历的过程中不能被终止,必须每一个值遍历一遍后才能停下来.<br>也就是说：<strong>你不能使用break来退出循环, 不能使用return语句来返回到外层</strong></p><h4 id="jquery中forEach"><a href="#jquery中forEach" class="headerlink" title="jquery中forEach"></a>jquery中forEach</h4><p>注意其与jQuery的$.each类似，只不过参数正好是相反的！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.each([], <span class="function"><span class="keyword">function</span>(<span class="params">index, value, array</span>) </span>&#123; <span class="comment">// ... &#125;);</span></span><br></pre></td></tr></table></figure><h3 id="2-for…in"><a href="#2-for…in" class="headerlink" title="2 for…in"></a>2 for…in</h3><h4 id="适合进行普通对象的遍历"><a href="#适合进行普通对象的遍历" class="headerlink" title="适合进行普通对象的遍历"></a>适合进行普通对象的遍历</h4><blockquote><p>for-in循环遍历对象的key，即键值对的键名。</p></blockquote><p>特性如下：</p><ol><li>方法遍历到的index（或key）类型为<code>String</code>，若无意间进行了字符串计算，会带来许多不便。</li><li><code>for-in</code>循环会遍历对象的所有<strong>可枚举属性</strong>。什么意思呢？就是除了遍历数组元素之外，还会遍历：自定义属性，原型上的属性。</li><li>一般不推荐遍历数组，因为for in遍历顺序是<strong>随机的</strong>，适合进行<strong>普通对象</strong>的遍历。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArry =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">myArry.desc =<span class="string">'four'</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">in</span> myArry)&#123; <span class="comment">//循环key</span></span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//"0"</span></span><br><span class="line"><span class="comment">//"1"</span></span><br><span class="line"><span class="comment">//"2"</span></span><br><span class="line"><span class="comment">//"3"</span></span><br><span class="line"><span class="comment">//"desc" 注意这里添加上去的属性也被遍历出来了</span></span><br></pre></td></tr></table></figure><p>for…in由于历史遗留问题，它遍历的实际上是对象的属性名称，一个Array数据也是一个对象，数组中的每个元素的索引被视为属性名称，所以我们可以看到使用for…in循环Array数组时，拿到的其实是每个元素的索引.</p><p>PS:若要避免原型链上的属性也被遍历到，可采用hasOwnProperty()方法去过滤掉对象原型链上的属性。</p><h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><h4 id="for-of循环适合遍历数组"><a href="#for-of循环适合遍历数组" class="headerlink" title="for-of循环适合遍历数组"></a>for-of循环适合遍历数组</h4><blockquote><p>循环遍历对象的值，即键值对的键值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArry =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">myArry.desc =<span class="string">'four'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> myArry)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>特性如下：</p><ul><li>这是最简洁、最直接的遍历数组元素的语法。</li><li>这个方法避开了<code>for-in</code>循环的所有缺陷，解决了<code>forEach</code>的不可中断问题。</li><li>for…of为ES6新增方法。</li><li>不推荐for…of遍历普通对象，实在需要用for…of遍历，可搭配<code>Object.keys()</code>实现。</li></ul><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student=&#123;</span><br><span class="line">    name:<span class="string">'wujunchuan'</span>,</span><br><span class="line">    age:<span class="number">22</span>,</span><br><span class="line">    locate:&#123;</span><br><span class="line">    country:<span class="string">'china'</span>,</span><br><span class="line">    city:<span class="string">'xiamen'</span>,</span><br><span class="line">    school:<span class="string">'XMUT'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(student))&#123;</span><br><span class="line">    <span class="comment">//使用Object.keys()方法获取对象key的数组</span></span><br><span class="line">    <span class="built_in">console</span>.log(key+<span class="string">": "</span>+student[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><strong>for…in与for…of</strong><br>格式对比：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>推荐在循环<strong>对象</strong>属性的时候，使用for…in,在遍历<strong>数组</strong>的时候的时候使用for…of。</p></li><li><p>for in是遍历<strong>键名</strong>，for of是遍历<strong>键值</strong>。</p></li><li><p>注意，for…of是ES6新引入的特性。修复了ES5引入的for…in的不足。</p></li></ol><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.cnblogs.com/ruoqiang/p/6217929.html" target="_blank" rel="noopener">forEach/for…in/for…of</a><br><a href="https://github.com/wujunchuan/wujunchuan.github.io/issues/11" target="_blank" rel="noopener">迭代器与for…of循环</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;map、eval、for…in、for…of、forEach&quot;&gt;&lt;a href=&quot;#map、eval、for…in、for…of、forEach&quot; class=&quot;headerlink&quot; title=&quot;map、eval、for…in、for…of、forEach&quot;&gt;&lt;/a&gt;map、eval、for…in、for…of、forEach&lt;/h2&gt;&lt;h3 id=&quot;最早的数组遍历方式&quot;&gt;&lt;a href=&quot;#最早的数组遍历方式&quot; class=&quot;headerlink&quot; title=&quot;最早的数组遍历方式&quot;&gt;&lt;/a&gt;最早的数组遍历方式&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = [&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;index &amp;lt; a.length;index++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a[index]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>HTML基础笔记</title>
    <link href="http://yoursite.com/2018/03/09/HTML%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/03/09/HTML基础笔记/</id>
    <published>2018-03-09T11:52:03.000Z</published>
    <updated>2018-03-22T08:31:05.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="html基础笔记"><a href="#html基础笔记" class="headerlink" title="html基础笔记"></a>html基础笔记</h1><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a><a href="http://tguide.qq.com/main/base.htm#css-list01" target="_blank" rel="noopener">命名规范</a></h3><h3 id="HTML是什么？"><a href="#HTML是什么？" class="headerlink" title="HTML是什么？"></a>HTML是什么？</h3><p>◾超文本标记语言（Hypertext Markup Language，HTML）通过标签语言来标记要显示的网页中的各个部分。一套规则，浏览器认识的规则。<a id="more"></a></p><h3 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h3><p><img src="./1520584805019.png" alt="Alt text"></p><p>◾&lt;!DOCTYPE html&gt; 告诉浏览器使用什么样的html或者xhtml来解析html文档<br>作用：声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。<br>◾<code>&lt;html&gt;&lt;/html&gt;</code>是文档的开始标记和结束标记。此元素告诉浏览器其自身是一个 HTML 文档，在它们之间是文档的头部<code>&lt;head&gt;</code>和主体<code>&lt;body&gt;</code>。<br>◾<code>&lt;head&gt;&lt;/head&gt;</code>元素出现在文档的开头部分。<code>&lt;head&gt;</code>与<code>&lt;/head&gt;</code>之间的内容不会在浏览器的文档窗口显示，但是其间的元素有特殊重要的意义。<br>◾<code>&lt;title&gt;&lt;/title&gt;</code>定义网页标题，在浏览器标题栏显示。<br>◾<code>&lt;body&gt;&lt;/body&gt;</code>之间的文本是可见的网页主体内容</p><p>2017.10.30<br>一、div布局基础</p><ol><li>网页分层：</li></ol><ul><li><strong>表现层  css</strong></li><li><strong>结构层  html</strong></li><li><strong>行为层  JS</strong></li></ul><ol><li><p><code>meta</code>标签:<br>关键字内容，提供网站相关信息给搜索引擎。<br><strong>常用作</strong>：提高排名，SEO（搜索引擎优化）<br>权重</p><ul><li><code>&lt;meta&gt;</code>元素可提供有关页面的元信息（meta-information），针对搜索引擎和更新频度的描述和关键词</li></ul></li></ol><ul><li><code>charset</code>字符集编码方式</li></ul><ol><li>常用标签</li></ol><ul><li><code>p</code>标签<br>段落标签！</li><li><code>h1-h6</code>标签<br>h1：logo主标题！<br>h2：区块标题！<br>h3-h6依次向下。<br><strong>不要滥用h标签！</strong></li></ul><hr><ul><li><code>sub</code>、<code>sup</code>下标上标</li><li><code>&lt;br/&gt;</code>换行</li><li><code>&lt;hr/&gt;</code>水平线</li><li><code>&lt;i&gt;</code>斜体标签（<code>&lt;em&gt;</code>效果相同）</li><li><code>&lt;b&gt;</code>粗体文本</li><li><code>&lt;strong&gt;</code>加粗<br><code>&lt;strong&gt;</code>标签和<code>&lt;em&gt;</code>标签一样，用于强调文本，但它强调的程度更强一些。<br><strong>不能滥用强调标签！</strong></li></ul><hr><ul><li>有序列表：<code>&lt;ol&gt;&lt;li&gt;</code>嵌套</li><li>无序列表：<code>&lt;ul&gt;&lt;li&gt;</code>嵌套</li><li>常见属性用法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol type=&quot;1&quot; start=&quot;10&quot;&gt;</span><br><span class="line">    &lt;li&gt;asd&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;      </span><br><span class="line">//以数字为序号的，从10开始的有序列表</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul type=&quot;circle&quot;&gt;</span><br><span class="line">&lt;li&gt;123&lt;/li&gt;</span><br><span class="line">&lt;li&gt;11&lt;/li&gt;</span><br><span class="line">&lt;li&gt;333&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;     </span><br><span class="line">//无序列表（circle空心圆、disc实心圆、square正方块）</span><br></pre></td></tr></table></figure><ul><li>自定义列表：<code>&lt;dl&gt;&lt;dt&gt;&lt;dd&gt;</code>嵌套使用 <pre><code>-`&lt;dt&gt;`标题-`&lt;dd&gt;`列表项 </code></pre></li></ul><hr><ul><li><p><code>&lt;img/&gt;</code>图片标签<br>1.<code>src</code>引入图片路径。<br>2.<code>alt</code>替代文本，seo抓取关键字。<br>3.<code>title</code>鼠标悬浮提示文字</p></li><li><p><code>background</code> 简写属性在一个声明中设置所有的背景属性。<br>可以设置如下属性：</p><ul><li>background-color             //颜色</li><li>background-position        //定位</li><li>background-size              //大小</li><li>background-repeat          //重复方式</li><li>background-origin    </li><li>background-clip</li><li>background-attachment</li><li>background-image          //图片<br><img src="./1509717789268.png" alt="Alt text"></li></ul></li></ul><p>★★★★</p><ul><li><code>background-attachment：fixed</code>图片固定在窗口的固定位置。</li></ul><hr><ul><li><code>&lt;a&gt;</code>超链接标签</li></ul><ol><li><code>href</code>属性：<br>(1)填写<strong>域名</strong>跳转链接<br>(2)填写下载或打开<strong>文件</strong>路径<br>(3)填写<code>#</code>代表空链接</li><li><code>target</code>属性窗口打开方式：<br>(1)<strong>_self</strong>当前窗口跳转链接<br>(2)<strong>_blank</strong>新窗口跳转链接 </li></ol><hr><ul><li><code>&lt;a&gt;</code>做锚点：页面内指定节点跳转！<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#head&quot;&gt;点击跳转&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;p id=&quot;head&quot;&gt;第一部分&lt;/p&gt;</span><br><span class="line">&lt;p&gt;第二部分&lt;/p&gt;</span><br><span class="line">&lt;p&gt;第三部分&lt;/p&gt;</span><br><span class="line">&lt;p&gt;第四部分&lt;/p&gt;</span><br><span class="line">//点击即可跳转到第一部分！</span><br></pre></td></tr></table></figure></li></ul><p>扩展：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//锚链接滑动跳转效果</span><br><span class="line">$(&apos;a&apos;).click(function() &#123;</span><br><span class="line">$(&apos;html, body&apos;).animate(&#123;</span><br><span class="line">scrollTop: $($.attr(this, &apos;href&apos;)).offset().top</span><br><span class="line">&#125;, 5000);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><ul><li>css样式引入方式：</li></ul><ol><li>行内样式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width:100px;height:200px;&quot;&gt;盒子&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol><li>内嵌式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">#a&#123;样式&#125;;</span><br><span class="line">.b&#123;样式&#125;;</span><br><span class="line"> &lt;/style&gt;</span><br></pre></td></tr></table></figure><ol><li>链接式<br>在<code>&lt;head&gt;&lt;/head&gt;</code>内写入：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt;</span><br></pre></td></tr></table></figure><ol><li>导入式（不建议使用）<br>导入样式和链接样式比较相似，采用@import样式导入CSS样式表，在HTML初始化时，会被导入到HTML或者CSS文件中，成为文件的一部分，类似第二种内嵌样式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">@(培训)[标签1, 标签2, 标签3];</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>四种CSS引入方式的优先级</li></ul><ol><li>就近原则</li><li>理论上：行内&gt;内嵌&gt;链接&gt;导入</li><li>实际上：内嵌、链接、导入在同一个文件头部，谁离相应的代码近，谁的优先级高</li></ol><hr><ul><li>color样式：</li></ul><ol><li>颜色或<code>#xxxxxx</code></li><li><code>rgb(x,x,x,x)</code>前三个为三原色掺比<strong>0-255</strong>.最后一个为透明的，<strong>0-1</strong>。</li></ol><hr><ul><li>浏览器默认给<code>body</code>加了一个<code>8px</code>的外边距</li><li><code>ul、ol</code>列表默认也有边距</li><li><code>li</code>默认有缩进</li><li>盒子的实际大小：<br>自身高度+内边距+边框</li><li>盒子的占位空间：<br>自身高度+内边距+边框+外边距</li></ul><hr><ul><li><strong>群组选择器：</strong><br><code>a,div, .box, .top{样式}</code></li><li><strong>通配符选择器：</strong>全局选中！<br><code>*{}</code>  配置方便但是影响性能！（页面渲染时要遍历所有标签，大型网站开发不用）</li><li><strong>类选择器：</strong><code>class</code></li><li><strong>后代选择器：</strong><code>#box p</code></li></ul><hr><ul><li><code>display</code>显示<br>1.<code>block</code>块级元素！<br>独占一行，可设置宽高。<br>没有设置宽高时，继承父级宽高。<br>可容纳其他块级元素和行内元素。</li></ul><p><strong>常见块级元素：</strong></p><ul><li>address - 地址<br>blockquote - 块引用<br>center - 举中对齐块<br>dir - 目录列表<br>div - 常用块级容易，也是css layout的主要标签<br>dl - 定义列表<br>fieldset - form控制组<br>form - 交互表单<br>h1 - 大标题<br>h2 - 副标题<br>h3 - 3级标题<br>h4 - 4级标题<br>h5 - 5级标题<br>h6 - 6级标题<br>hr - 水平分隔线<br>isindex - input prompt<br>menu - 菜单列表<br>noframes - frames可选内容（对于不支持frame的浏览器显示此区块内容）<br>noscript - 可选脚本内容（对于不支持script的浏览器显示此内容）<br>ol - 排序列表<br>p - 段落<br>pre - 格式化文本<br>table - 表格<br>ul - 非排序列表</li></ul><p>2.<code>inline</code>内联元素！<br>不可设置宽高<br>可与其他元素同处一行<br>只能容纳内联元素<br>不支持设置上下内、外边距，可设置左右内、外边距。<br>内联元素间有<strong>空格</strong>，就像文字间隙！<br><img src="./1509711818527.png" alt="Alt text"></p><p>如上，设置内边距时，元素内容位置不变，内边距会上下撑开，从而覆盖在其他元素上。</p><p><strong>常见内联元素：</strong></p><ul><li>a - 锚点<br>abbr - 缩写<br>acronym - 首字<br>b - 粗体（不推荐）<br>bdo - bidi override<br>big - 大字体<br>br - 换行<br>cite - 引用<br>code - 计算机代码（在引用源码的时候需要）<br>dfn - 定义字段<br>em - 强调<br>font - 字体设定（不推荐）<br>i - 斜体<br>img - 图片<br>input - 输入框<br>kbd - 定义键盘文本<br>label - 表格标签<br>q - 短引用<br>s - 中划线（不推荐）<br>samp - 定义范例计算机代码<br>select - 项目选择<br>small - 小字体文本<br>span - 常用内联容器，定义文本内区块<br>strike - 中划线<br>strong - 粗体强调<br>sub - 下标<br>sup - 上标<br>textarea - 多行文本输入框<br>tt - 电传文本<br>u - 下划线<br>var - 定义变量</li></ul><p>★★★★<br>其中：<code>img</code>较为特殊。img元素作为替换元素，有着类似于Inline-block的行为！</p><ol><li>可以设置width/height;</li><li>默认的，img元素在屏幕占据的空间与其图片的实际像素一致</li><li>如果img标签的包裹元素为也为inline元素，则img的边界可以超出其直接父元素的边界，直到自己的宽、高达到最大或者设定值为止，而且文档流中img的兄弟元素也不能遮盖住img。最常见的就是<code>&lt;a&gt;</code>里面包含的<code>&lt;img&gt;</code></li><li>可以通过<code>text-alin：center</code>实现居中！</li></ol><p>3.<code>inline-block</code>行内块级元素<br>兼具块级元素与内联元素的特性</p><hr><ul><li><strong>行内块级元素特性：</strong><br>※ <code>margin：0 auto</code>只对块级元素有效！<br>且<code>IE6、IE7</code>不支持！<br>※ <code>text-align</code>文字对齐方式<br>1.<code>left</code><br>2.<code>center</code><br>3.<code>right</code><br>※<strong>行内块级元素作为文字解析</strong>，因此可以通过<code>text-align：center</code>来实现<strong>居中对齐</strong>。</li></ul><hr><ul><li>外边距合并：<br>当块级元素的外边距相遇时会发生合并，合并后的共同外边距以较大者为准。<br>1.同级块级元素合并：<br>合并后以较大者作为两者间距！<br>2.父子块级元素合并：<br>合并后以较大者作为此方向公共外边距。</li></ul><ul><li>解决边距合并方法：<br>改变元素类型，使其不为块级元素。<br>或者在元素间插入文字等其他元素。</li></ul><hr><p>★★★★</p><ul><li><code>p</code>标签不能包<code>p</code>标签和块级元素。</li><li><code>a</code>标签不能包<code>a</code>标签。可以包裹其它。<ul><li>但是<code>a</code>标签无法完美包裹<strong>行内块级元素</strong>和<strong>块级元素</strong>，但是页面中常用这种包裹。因为这样做可以使整个div都可以点击访问，用户体验较好。</li></ul></li></ul><hr><p>★★★★</p><ul><li>垂直对齐方式<code>vertical-align</code><ul><li><strong>只对行内或者行内块有效！</strong></li><li>基线表示： <img src="./1509881745425.png" alt="Alt text"></li><li><code>行内元素</code>和<code>行内块元素</code>对齐方式！<br>1.行内块没有文字的时候，块底端默认以父级的基线（<code>baseline</code>）对齐！</li><li><img src="./1509881680352.png" alt="Alt text"><br>2.行内块有文字的时候，默认块的基线与父元素的基线对齐。<ul><li><img src="./1509889324956.png" alt="Alt text"></li></ul></li></ul></li></ul><ul><li>其他对齐方式：<ul><li><code>top</code>  元素的顶端与父元素行高（<strong>不是高度</strong>）的顶端对齐</li><li><code>bottom</code>    元素的底端与父元素行高底端对齐</li><li><code>middle</code>    元素的中线与父元素行高中线对齐</li><li><code>text-top</code>元素的顶端与父元素中文字顶线对齐</li><li><img src="./1509890321829.png" alt="Alt text"></li><li><code>text-bottom</code>元素的底端与父元素中文字底线对齐</li><li><img src="./1509890293480.png" alt="Alt text"></li><li><strong>文字对齐受行高影响，不受父元素盒子大小影响，行高若超过父盒子大小，内容则会溢出。</strong> </li><li><strong>行高有继承效果！</strong></li></ul></li></ul><hr><ul><li><strong>HTML5 规范声明：应该使用 <code>&lt;h1&gt; - &lt;h6&gt;</code> 来表示标题，使用 <code>&lt;em&gt;</code> 标签来表示强调的文本，应该使用 <code>&lt;strong&gt;</code> 标签来表示重要文本，应该使用 <code>&lt;mark&gt;</code> 标签来表示标注的/突出显示的文本。</strong></li></ul><hr><p>2017.11.16</p><ul><li>鼠标指针<ol><li><code>cursor</code> 鼠标样式指针<ul><li><code>pointer</code>   手型</li><li><code>move</code>     可移动指针</li><li><code>text</code>  光标指示文本</li><li><code>wait</code>       加载中</li><li><code>help</code>        帮助</li></ul></li><li>自定义指针<ul><li><code>cursor：url（图片路径），pointer</code></li></ul></li></ol></li><li>透明度<ul><li><code>opacity</code>：整个盒子（包括其子元素）透明度变化 0-1。</li><li><code>background-color：rgb（255,0,0,0.5</code>：最后一项只控制背景颜色的透明度。 </li><li>rgb<strong>是css3的属性，IE一般不兼容</strong></li><li>background-color<strong>在低版本的IE中不兼容</strong></li></ul></li></ul><hr><ul><li>伪类选择器<ul><li><code>.box：hover</code></li></ul></li></ul><hr><p>2017.11.17</p><ul><li><p>字体</p><ul><li><p><code>font-family</code>字体样式，包括<strong>微软雅黑，宋体，楷体等常见字体群</strong></p></li><li><p><code>font-size</code>字体大小</p></li></ul><ol><li><p><strong>PS:</strong>一般浏览器默认样式为<code>16px</code>，火狐浏览器支持<code>12px</code>以下的字体大小，其他浏览器不支持<code>12px</code>以下的字体大小。</p></li><li><p><code>em</code>做文字大小单位时，以父元素的文字大小为参考基准单位。</p></li><li><code>em</code>做宽高时，以当前元素的字体大小做基准。</li><li>eg：浏览器默认字体大小<code>16px</code>，<code>font-size：2em</code>则字体大小为<code>32px</code>。<code>width：10em</code>则元素宽度为<code>320px</code>。</li><li><code>rem</code>：以根标签<code>html</code>的字体大小作为基准。多用于移动端！</li></ol><ul><li><code>font-weight</code> 字体粗细<ol><li>取值：<code>100-900</code>或者<code>normal、bold</code></li></ol></li><li><code>font-style</code>字体风格。<ol><li><code>italic</code>字体倾斜  </li><li><code>oblique</code>强制倾斜</li><li><code>normal</code>正常显示</li></ol></li></ul></li></ul><p>★★</p><ul><li><code>font-wariant</code>字体大小写<ul><li><code>small-caps</code>小写字母大写。</li></ul></li></ul><p>★★★★</p><ul><li><strong>font的所有属性都会被继承</strong> </li><li><strong>复合样式</strong>：<ul><li><img src="./1510887976987.png" alt="Alt text"><br><br></li><li><img src="./1510887886252.png" alt="Alt text"></li></ul></li></ul><hr><p>★★★★</p><ul><li><p><code>text</code> 文本</p><ul><li><code>text-transform</code>本文字母大小写<ol><li><code>uppercase</code>小写字母大写</li><li><code>lowercase</code>大写字母小写</li><li><code>capitalize</code>单词首字母大写<ul><li><code>text-align</code>文本水平对齐方式</li></ul></li><li><code>right</code></li><li><code>left</code></li><li><code>center</code> </li><li><code>行内元素无法使用！</code><ul><li><code>text-indent</code>文本段落缩进</li></ul><ol><li><code>px</code></li><li><code>em</code></li><li><code>行内元素无法使用！</code></li></ol></li></ol></li><li><code>text-decoration</code>本文修饰方式<ol><li><code>underline</code>下划线</li><li><code>line-through</code>删除线</li><li><code>overline</code></li></ol></li><li><code>letter-spacing</code>字符间距  单位：<code>px</code></li><li><code>word-spacing</code>单词间距  单位：<code>px</code></li><li><code>white-space</code>换行方式<pre><code>1. `normal`默认方式2. `nowrap`不换行</code></pre></li><li><p><code>word-break</code>css3中换行方式</p><pre><code>1. `normal`默认方式2. `break-all`空间不足时，会拆分完整单词来换行。3. `keep-all`空间不足，不会拆分单词，而是将其整体换到下一行。4.  `行内元素无法使用！`</code></pre></li><li><p><code>text-overflow</code>文本超出设置</p><pre><code>1. `clip`         文本超出2. `ellipsis`   文本超出省略处理3. 配合`overflow：hidden`使用，且`行内元素无法使用！` </code></pre></li><li><img src="./1510902478833.png" alt="Alt text"></li></ul></li></ul><hr><ul><li>特殊字符<ul><li>浏览器会将多个空格当做一个空格处理。</li><li><code>&amp;nbsp；</code>  空格占位符，一个代表一个空格。</li><li><code>&amp;lt；</code>小于符号</li><li><code>&amp;gt；</code>大于符号</li><li><code>&amp;copy；</code>版权符号</li><li><code>reg；</code> 注册商标</li></ul></li></ul><hr><p>2017.11.18</p><p>####高级选择器及a伪类</p><p><strong>一、初级选择器</strong></p><ul><li>后代选择器</li><li>群组选择器<br>★★★★</li><li>子元素选择器：如<code>div &gt; p</code>直系父子才行。<br>★★★★</li><li><p>兄弟选择器：如：<code>div + div</code> 表示div的兄弟div元素。样式只加给<strong>相邻的</strong>兄弟，兄弟间不能有任何其他标签！且样式对元素自身无效，即<strong>自身不变！！！</strong>  。</p><p>★★★★<br><strong>一、属性选择器</strong><br>：元素拥有的任何<strong>属性（包括自定义属性）</strong>都可以作为选择的依据。</p><pre><code>1. 如： `[class]`表示选中有class属性的元素</code></pre><p>或<code>[class=&quot;text&quot;]</code>表示选中有class属性，且属性值唯一为text的元素。<br>或<code>[class=&quot;text-top&quot;]</code>表示选中有class属性，且值唯一为text-top的元素。<br>总结：<strong>可以灵活限定选择范围。</strong></p><pre><code>2. 如：`class ~=&quot;nav&quot;` ，表示选中具备`class属性`，且有一个（可有多个）为`nav`的值的元素。3. 如：`[class |=&quot;nav&quot;]`,表示选中具备class属性，且有以nav或者nav-开头的值的元素。4. **组合使用**：如    - `[href][titile=&quot;name&quot;]`表示选中具有href属性，且title属性值唯一为name的元素。</code></pre></li></ul><p><strong>二、伪类选择器</strong></p><ul><li><code>a:hover</code>鼠标悬停触发事件</li><li><code>a：link</code>匹配所有没有被点击过的链接</li><li><code>a：visited</code>匹配所有被点击过的链接</li><li><code>a：active</code>匹配正在点击触发的链接</li><li><strong>同理其他元素也可以应用以上伪类</strong></li><li>★★当<code>a:hover</code>和<code>a：active</code>同时存在的时候，顺序不能颠倒，否则active样式不生效。</li></ul><p><strong>三、伪元素选择器</strong></p><ul><li><code>p：after</code>添加新元素到目标元素后面，默认生成的是<strong>行内元素</strong>。<br>如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">元素！</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;原来&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">样式！</span><br><span class="line">&lt;style&gt;</span><br><span class="line">p&#123;</span><br><span class="line">    font-size:30px; </span><br><span class="line">    background-color: orange;</span><br><span class="line">&#125;</span><br><span class="line">p:after&#123;</span><br><span class="line">    content:&quot;新增&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><p>结果如图：<img src="./1511101115990.png" alt="Alt text"></p><ul><li><code>p：before</code>添加新元素到目标元素前面，默认是<strong>行内元素</strong>。</li></ul><p>####四、应用和优先级讨论</p><ul><li>单个选择器优先级<br> <strong>ID选择器&gt;类选择器&gt;标签选择器&gt;通配符选择器</strong> </li><li>组合选择器优先级<strong>计算</strong><pre><code>★★★★我们把CSS的特殊性分为4个等级，每个等级代表一类选择器。每个等级的值为其所代表的选择器的个数乘以这一等级的权值，最后把所有等级的值相加得出选择器的特殊值。</code></pre>  <strong>4个等级的定义如下：</strong><ul><li>第一等：代表内联样式，如: style=””，权值为1000。</li><li>第二等：代表ID选择器，如：#content，权值为100。</li><li>第三等：代表类，伪类和属性选择器，如.content，权值为10。</li><li>第四等：代表类型选择器和伪元素选择器，如div p，权值为1。<br><strong>权重一样时后者覆盖前者</strong></li></ul></li></ul><hr><p>2017.11.20</p><p>####样式优先级<br>行内样式&gt;内部样式&gt;外部引入样式  <code>!important</code>强行提升重要性至最高</p><p>1<code>@import url(&quot;相对路径&quot;)</code>，需要顶格写在style中，只能引入CSS文件。<br>引入顺序：</p><ul><li><code>link</code>引入的css会在页面加载时同步加载。</li><li><code>import</code>引入的css在页面加载完才能加载。<br>####css3</li><li><p>圆角<code>border-radius</code></p><ol><li>四个值时，分别对应四个角；</li><li>三个值时，分别表示左上，右上左下，右下；</li><li>两个值时，分别表示左上右下，右上左下；</li><li>一个值时，表示四个角</li><li>实现圆形 <img src="./1511173588921.png" alt="Alt text"></li></ol></li><li><p>阴影<code>box-shadow</code></p><ol><li>有五类值<img src="./1511173978654.png" alt="Alt text"></li><li>阴影可以堆叠<img src="./1511174671356.png" alt="Alt text"><br>★★★★<ul><li><code>overflow：hidden</code>溢出隐藏</li><li><code>overflow-y：hidden</code>单方向溢出隐藏</li></ul></li></ol></li></ul><hr><p>2017.11.21</p><p>####浮动float<br>★★★★</p><ul><li>浮动元素会脱离文档流，不占空间；默认会覆盖在普通DOM元素上。</li><li>浮动会造成父级的盒子塌陷</li><li>浮动最初运用是为了实现<strong>文字环绕</strong></li><li>浮动会挤压文本格式的内容（包括文字，行内元素，行内块级元素）</li><li>父级规定宽高之后，尽管浮动脱离了文档流，但内容不够依旧会掉下去。</li><li>浮动只会在父元素内部浮动，不会脱离父级限定的宽高范围。</li><li>浮动会让元素变为块级元素。</li><li>浮动排列原则：<ul><li>后一个只会被紧挨的前一个影响，空间够则紧挨排列在后，不够空间，会以前一个盒子的高度为基准换到下一行。</li><li><img src="./1511271243903.png" alt="Alt text"><br>红色盒子卡住了黑色盒子，在空间不够时，会掉到下一行，<strong>但不会填补空缺，而是以红色盒子高度为基准</strong>。<ul><li><img src="./1511271379599.png" alt="Alt text">对比可知，<strong>浮动排列规则</strong>。</li></ul></li></ul></li></ul><p>★★★★★</p><p>####清除浮动：清除浮动造成的父级元素塌陷</p><ul><li><p><code>clear</code>，三个值:left,right,both.</p><ul><li><img src="./1511266569353.png" alt="Alt text"><br>一般是通过<strong>创建一个新的同级的元素盒子</strong>，给他的css添加clear属性，来清除它前面同级元素的浮动。</li></ul></li><li><p>伪元素法：通过after添加的dom元素，不在页面dom树种，是<strong>主流的清除浮动方法</strong>，原理同第一种。</p><ul><li>具体实现方法如图：<img src="./1511267515655.png" alt="Alt text"></li></ul></li></ul><p>★★★★★</p><p>####最小宽度和最大宽度</p><ul><li><p><code>min-width</code>:<strong>用像素设定大小时，常限定最小宽度，防止盒子变形。</strong></p><ul><li>此时，浏览器窗口继续变小之后，元素不会变形。即小于这个宽度后，盒子不会再被挤压变小，而是被遮盖。</li></ul></li><li><p><code>max-width</code>:<strong>百分比设定大小时，常限定最大宽度，防止盒子变形。</strong><br>   -此时，浏览器窗口继续变大后，元素盒子不会再拉长。即大于这个宽度后，盒子宽度不再增加。<br>####定位</p></li><li><p><code>position</code>定位</p><ol><li><code>static</code>默认，没变化</li><li><code>relative</code>相对定位<pre><code>- 相对定位半脱离文档流，相对原来位置移动，子元素也会随着元素一起移动。- 但是不会造成盒子塌陷，即在父级中原来的空间占位不会消失。- 相对定位不会改变元素类型</code></pre></li><li><code>absolute</code>绝对定位<pre><code>- 绝对定位完全脱离文档流，相对有定位属性的父级元素移动，如果没有，则参考body移动。- 会造成盒子塌陷，在父级中的空间占位消失。- 绝对定位会改变元素类型为**块级**- `margin：auto`失效</code></pre></li><li><code>fixed</code>固定定位<ul><li>相对浏览器窗口定位，不会移动</li></ul></li></ol></li><li><p><code>z-index</code>层级</p><ol><li>绝对定位层级&gt;相对定位（<strong>给出位移值的</strong>）层级&gt;浮动元素层级&gt;普通元素层级（<strong>没给位移值的相对定位层级</strong>）</li><li>默认层级都是0</li><li>层级都是相对的，在父级内部，同级元素进行比较。</li><li>不同级（辈分）的元素不能比较层级。</li></ol></li></ul><hr><p>2017.11.23</p><p>####表单<code>form</code></p><ul><li><code>action</code>属性：标识表单提交的地址。</li><li><code>method</code>属性，表单数据的提交方式。<ol><li><code>get</code>方法</li><li><code>post</code>方法 </li></ol></li><li><code>input</code>元素：输入框。<ol><li><code>type</code>类型属性： text （文本框） ，password（密码框），radio（单选框），checkbox（复选框），button（普通按钮），file（文件上传）<strong>可限定文件类型</strong>！！<pre><code>- 复选框![Alt text](./1511432806144.png)- 复选框中加上`checked`表示默认选中，`disabled`禁制使用。- 普通按钮![Alt text](./1511432786801.png)- 重置按钮![Alt text](./1511432902424.png)- 提交按钮![Alt text](./1511433177191.png)- 提交数据包括：name属性的关键字和value属性的值，两者组成的键值对。</code></pre></li><li><code>lable</code>绑定文本到目标ID的选择框上。可实现<strong>文字点击选中效果</strong>！<pre><code>- ![Alt text](./1511432600393.png)</code></pre></li><li><code>placeholder</code>框内提示信息</li></ol></li><li><code>selection</code>下拉选框<ol><li><code>option</code>下拉选项。加上<code>selected</code>则表示此项默认选中。</li></ol></li><li><code>textarea</code>文本区域 </li><li><code>fieldset</code>组合表单控件，是块级元素。<ol><li><code>legend</code>此表单区块的标题</li></ol></li><li></li><li><p>PS：<code>outline：none</code>去掉默认的焦点元素框，默认是蓝色。</p></li></ul><p>####focus伪类，常用于表单元素</p><ul><li>如：<img src="./1511442146588.png" alt="Alt text"><br><img src="./1511442186875.png" alt="Alt text"></li></ul><p>####表格<code>table</code></p><ul><li>表格的一般组成<img src="./1511443794429.png" alt="Alt text"><img src="./1511443884334.png" alt="Alt text"><br>包括<code>thead</code>，<code>tbody</code>，<code>tfoot</code>；</li><li><strong>表格具备对齐属性：即改变某一行或者某一列甚至某个格子时，其他元素会行列对齐次</strong>。</li><li><code>table</code>的<code>border</code>属性只对最外层加边框。</li><li><p><strong>单元格合并</strong></p><ol><li><code>colspan=？</code>不同列合并，值表示合并的个数，多的单元格会被挤压。</li><li><code>rowspan=？</code>不同行合并，值表示合并的个数，多的单元格会被挤压。</li></ol></li><li><p>单元格默认类型为<code>table-cell</code>，<code>td，tr，th</code>不支持<code>margin</code>属性，且有默认的<code>padding=1</code>。</p></li><li>边框间距<code>border-spacing</code>：<br>加给<code>table</code>标签，可以控制边框距离，默认两个值，分别控制<strong>x，y</strong>。</li><li>边框合并<code>border-collapse：collapse</code></li></ul><hr><p>2017.11.24</p><p>####<code>iframe</code>框架<br>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p><ul><li><img src="./1511526913597.png" alt="Alt text"></li><li>通过对<code>a</code>标签的<code>target</code>属性绑定<code>iframe</code>的name值，可实现链接跳转的绑定，及对应显示。即点击a标签对应文字，框架内可显示京东的首页！</li></ul><p>####css继承总结</p><ul><li>默认继承的有：<code>color、font、text-align、text-indent、letter-spacing、word-spacing、list-style</code></li><li>a标签的颜色值不继承父级的<code>color</code>，有自己的默认颜色。</li><li>可以使用<code>inherit</code>来明确继承父级相应的属性值。<br>####css重用<br>通过给元素添加具有<strong>固定样式的类</strong>，达到样式的高效重复使用的目的。<br>★★★★★<br><strong>选项卡图标！！！</strong></li><li>用法如下：<img src="./1511529464616.png" alt="Alt text"><br>####css书写顺序</li></ul><p>第一位：关乎元素类型的</p><ol><li>display</li><li>positon</li><li>float<br>第二位：元素自身的特性属性<ol><li>width</li><li>height</li><li>border</li><li>margin</li><li>padding<br>第三位：其他属性</li><li>text</li><li>font</li><li>background<br>第四位：css3的属性</li></ol></li></ol><p>####浏览器前缀<br>谷歌：<code>-webkit-</code><br>火狐：<code>-moz-</code><br>欧朋：<code>-o-</code><br>IE：<code>-ms-</code></p><p>####<code>swiper</code>轮播插件</p><p>####阿里图标<br>是一种字体图标，不会因为放大缩小而模糊。<br>一、单色图标<br>兼容IE8+以上所有现代浏览器。<br>不支持彩色图标！<br>但可以通过CSS进行后期修改。<br><strong>通过引入css文件，给i标签加特定的类名实现</strong><br>二、多色图标<br>性能较差，兼容性较差，不推荐使用。<code>通过引入JS文件，些svg代码块实现</code></p><hr><p>@(培训)[标签1, 标签2, 标签3]</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;html基础笔记&quot;&gt;&lt;a href=&quot;#html基础笔记&quot; class=&quot;headerlink&quot; title=&quot;html基础笔记&quot;&gt;&lt;/a&gt;html基础笔记&lt;/h1&gt;&lt;h3 id=&quot;命名规范&quot;&gt;&lt;a href=&quot;#命名规范&quot; class=&quot;headerlink&quot; title=&quot;命名规范&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://tguide.qq.com/main/base.htm#css-list01&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;命名规范&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;HTML是什么？&quot;&gt;&lt;a href=&quot;#HTML是什么？&quot; class=&quot;headerlink&quot; title=&quot;HTML是什么？&quot;&gt;&lt;/a&gt;HTML是什么？&lt;/h3&gt;&lt;p&gt;◾超文本标记语言（Hypertext Markup Language，HTML）通过标签语言来标记要显示的网页中的各个部分。一套规则，浏览器认识的规则。
    
    </summary>
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的闭包</title>
    <link href="http://yoursite.com/2017/10/24/%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2017/10/24/闭包/</id>
    <published>2017-10-24T07:31:54.000Z</published>
    <updated>2018-04-01T15:34:12.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前置知识："><a href="#0-前置知识：" class="headerlink" title="0 前置知识："></a>0 前置知识：</h2><p>基于js的函数作用域，局部变量的特性，函数外部是无法访问函数内部的变量的。<br><strong>而有时我们恰恰有这样的需求，这就有了闭包的方法。</strong></p><h2 id="1-闭包的概念："><a href="#1-闭包的概念：" class="headerlink" title="1 闭包的概念："></a>1 闭包的概念：</h2><p><strong>闭包是指可以访问另一函数内部变量的函数</strong><br>通常构造闭包的方式是在函数中定义一个函数，用做访问函数内部变量的<strong>“钩子”</strong>，或者可以理解为开辟了外部访问函数内部变量的<strong>“绿色通道”</strong>。<br><a id="more"></a></p><h2 id="2-闭包的原理分析："><a href="#2-闭包的原理分析：" class="headerlink" title="2 闭包的原理分析："></a>2 闭包的原理分析：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(n); <span class="comment">// 999</span></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>遵循js作用域链的规则，上述代码中，f2可以访问f1的变量n。因此我们只需要<strong>将f2返回出来</strong>，就可以实现闭包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(n); </span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> result=f1();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> result=f1();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 999</span></span><br><span class="line"></span><br><span class="line">　　nAdd();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>我们发现，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在<strong>内存</strong>中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被<strong>垃圾回收机制（garbage collection）回收</strong>。<br>另外，nAdd也是一个闭包，因此可以访问函数f1内的n，若是换成在函数外定义一个nAdd函数，<strong>浏览器会报错</strong>，无法访问到n。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result(); <span class="comment">// 999</span></span><br><span class="line"><span class="keyword">var</span> nAdd = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">n += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">nAdd();</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180308170052197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl0dGxlX0NoZW5I/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="3-闭包的优缺点："><a href="#3-闭包的优缺点：" class="headerlink" title="3 闭包的优缺点："></a>3 闭包的优缺点：</h2><blockquote><p>1.通过闭包获取到的变量会永久的保留在内存中，不会被回收，因此闭包要慎用，否则会给浏览器带来较大的负担，影响性能。严重的会导致内存泄漏，解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><ol><li>通过闭包访问的，函数内部的变量不再隐私，可以在函数外对其进行修改，因此在对闭包获取的变量进行操作时，不要随便更改其值。</li></ol></blockquote><h2 id="4-闭包的常见使用方法："><a href="#4-闭包的常见使用方法：" class="headerlink" title="4 闭包的常见使用方法："></a>4 闭包的常见使用方法：</h2><p>1.通过将函数<code>return</code>出去，使其可在外部访问。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line">foo()();</span><br></pre></td></tr></table></figure></p><p>2 通过将其作为想要执行的函数的参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在foo()函数的作用域中声明，在bar()函数的作用域中被调用的baz()函数是闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar(baz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3 将内部函数赋值给一个外部变量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inner;</span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">'local'</span>;</span><br><span class="line">    <span class="keyword">var</span> N = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;;</span><br><span class="line">    inner = N;</span><br><span class="line">&#125;;</span><br><span class="line">F();</span><br><span class="line"><span class="built_in">console</span>.log(inner());</span><br></pre></td></tr></table></figure></p><h2 id="5-通过闭包嵌套解决常见的for循环i问题"><a href="#5-通过闭包嵌套解决常见的for循环i问题" class="headerlink" title="5 通过闭包嵌套解决常见的for循环i问题"></a>5 通过闭包嵌套解决常见的for循环i问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createFunctions());</span><br></pre></td></tr></table></figure><p>以上代码，for循环执行中，每次匿名函数调用完后，执行环境的作用域链被销毁，但是活动对象仍然保留。<br>因此，<code>createFunction()</code>函数会返回一个<strong>函数数组</strong>，每个元素都是一个函数指针，在调用执行时找i，此时i均为i=10。<br>通过闭包解决上述问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;  <span class="comment">//i将作为参数传进来，保存在作用域内，因此每个num都在不同的作用域中，通过闭包访问的值就是正常我们需要的。</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num</span><br><span class="line">&#125;;</span><br><span class="line">&#125;(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createFunctions());</span><br></pre></td></tr></table></figure><h2 id="6-闭包实现私有变量封装"><a href="#6-闭包实现私有变量封装" class="headerlink" title="6 闭包实现私有变量封装"></a>6 闭包实现私有变量封装</h2><p>借助闭包，同样可以封装一个私有变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_counter</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = initial || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            x += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 = create_counter();</span><br><span class="line">c1.inc(); <span class="comment">// 1</span></span><br><span class="line">c1.inc(); <span class="comment">// 2</span></span><br><span class="line">c1.inc(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = create_counter(<span class="number">10</span>);</span><br><span class="line">c2.inc(); <span class="comment">// 11</span></span><br><span class="line">c2.inc(); <span class="comment">// 12</span></span><br><span class="line">c2.inc(); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure><p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，<strong>从外部代码根本无法访问到变量x</strong>。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。<br>参考文章：<br><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">闭包，阮一峰</a><br><a href="http://blog.csdn.net/u011240877/article/details/70202456" target="_blank" rel="noopener">JavaScript闭包</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前置知识：&quot;&gt;&lt;a href=&quot;#0-前置知识：&quot; class=&quot;headerlink&quot; title=&quot;0 前置知识：&quot;&gt;&lt;/a&gt;0 前置知识：&lt;/h2&gt;&lt;p&gt;基于js的函数作用域，局部变量的特性，函数外部是无法访问函数内部的变量的。&lt;br&gt;&lt;strong&gt;而有时我们恰恰有这样的需求，这就有了闭包的方法。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-闭包的概念：&quot;&gt;&lt;a href=&quot;#1-闭包的概念：&quot; class=&quot;headerlink&quot; title=&quot;1 闭包的概念：&quot;&gt;&lt;/a&gt;1 闭包的概念：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;闭包是指可以访问另一函数内部变量的函数&lt;/strong&gt;&lt;br&gt;通常构造闭包的方式是在函数中定义一个函数，用做访问函数内部变量的&lt;strong&gt;“钩子”&lt;/strong&gt;，或者可以理解为开辟了外部访问函数内部变量的&lt;strong&gt;“绿色通道”&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>CSS盒模型</title>
    <link href="http://yoursite.com/2017/10/24/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/10/24/CSS盒模型/</id>
    <published>2017-10-24T07:31:54.000Z</published>
    <updated>2018-04-01T15:42:41.362Z</updated>
    
    <content type="html"><![CDATA[<p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。</p><p><img src="http://img.blog.csdn.net/2018022723385666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl0dGxlX0NoZW5I/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><a id="more"></a></p><ul><li>Margin(外边距) - 清除边框外的区域，外边距是透明的。</li><li>Border(边框) - 围绕在内边距和内容外的边框。</li><li>Padding(内边距) - 清除内容周围的区域，内边距是透明的。</li><li>Content(内容) - 盒子的内容，显示文本和图像。<h3 id="box-sizing盒模型解析方式"><a href="#box-sizing盒模型解析方式" class="headerlink" title="box-sizing盒模型解析方式"></a><code>box-sizing</code>盒模型解析方式</h3><strong>引子：</strong>通常情况下，被更多人认知的盒模型就是简单盒模型，简单盒模型在早期IE（ IE 5 和 6 ）时期有一种怪异模式下的解析方式，也就是现在的border-box，后来W3C制定的标准以后规定在标准解析模式下使用标准盒模型(content-box)。</li></ul><p>例子：设定两个参数相同的不同<strong>盒模型！</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>与<span class="selector-tag">css</span>设定</span><br><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line"><span class="attribute">box-sizing</span>: content-box;</span><br><span class="line"><span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br><span class="line"><span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://img.blog.csdn.net/20180227233350687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl0dGxlX0NoZW5I/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><ol><li><code>content-box</code>标准盒模型<br><img src="http://img.blog.csdn.net/20180227233400522?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl0dGxlX0NoZW5I/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><pre><code>● width = 内容的宽度● height = 内容的高度</code></pre></li><li><code>border-box</code>怪异盒模型<br><img src="http://img.blog.csdn.net/20180227233409432?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl0dGxlX0NoZW5I/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><pre><code>● width = border + padding + 内容的宽度●height = border + padding + 内容的高度</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/2018022723385666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl0dGxlX0NoZW5I/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="盒模型" scheme="http://yoursite.com/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>JS作用域详解</title>
    <link href="http://yoursite.com/2017/10/22/JS%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/10/22/JS作用域详解/</id>
    <published>2017-10-22T05:11:01.000Z</published>
    <updated>2018-04-01T14:49:16.621Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="一、涉及概念、知识点"><a href="#一、涉及概念、知识点" class="headerlink" title="一、涉及概念、知识点"></a>一、涉及概念、知识点</h2><h3 id="1-执行环境"><a href="#1-执行环境" class="headerlink" title="1.执行环境"></a>1.执行环境</h3><ul><li><strong>执行环境</strong>定义了变量或者函数有权访问的其他数据，执行环境有与之相关联的变量对象。</li><li><strong>执行环境</strong>会在环境内所有代码执行完毕后，销毁该环境。（全局执行环境会等到应用程序退出或者浏览器窗口关闭才会销毁）<a id="more"></a></li></ul><ol><li>全局执行环境<br>全局执行环境也即window对象，因此所有的全局变量、函数都是window对象的属性和方法。</li><li>局部执行环境（函数执行环境）<br>当执行流进入一个函数时，执行环境变为这一特定函数的局部执行环境。待函数执行完后，栈将环境弹出，转而进入下一个执行环境。</li></ol><p><strong>正由于不同执行环境间的切换，因此产生了变量和函数的作用域</strong></p><h3 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2.作用域"></a>2.作用域</h3><ul><li><strong>作用域</strong>代表变量与函数的可访问范围，可以说作用域控制着变量与函数的可见性和生命周期。</li><li>在JavaScript中，变量的作用域有<strong>全局</strong>作用域和<strong>局部</strong>作用域两种，局部作用域又称为函数作用域。<h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4></li></ul><p>拥有全局作用域的对象：<br>1.程序最外层定义的函数或者变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"tsrot"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">hello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(a);     <span class="comment">//能访问到tsrot</span></span><br><span class="line">hello();      <span class="comment">//能访问到tsrot</span></span><br><span class="line">sayHello();   <span class="comment">//能访问到hello函数，然后也能访问到tsrot</span></span><br></pre></td></tr></table></figure></p><p>2.所有末定义直接赋值的变量（不推荐）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">a = <span class="string">"tsrot"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"hello tsrot"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(a);  <span class="comment">//能访问到tsrot</span></span><br><span class="line">alert(b);  <span class="comment">//error 不能访问</span></span><br></pre></td></tr></table></figure></p><p>3.所有window对象的属性和方法<br>如window.name、window.location、window.top等等。</p><h4 id="局部作用域（函数作用域）"><a href="#局部作用域（函数作用域）" class="headerlink" title="局部作用域（函数作用域）"></a>局部作用域（函数作用域）</h4><p>局部作用域在函数内创建，在<strong>函数内可访问，函数外不可访问</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"tsrot"</span>;</span><br><span class="line">alert(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello(); <span class="comment">//函数内可访问到tsrot</span></span><br><span class="line">alert(a); <span class="comment">//error not defined</span></span><br></pre></td></tr></table></figure></p><h3 id="3-作用域链"><a href="#3-作用域链" class="headerlink" title="3.作用域链"></a>3.作用域链</h3><h4 id="▷作用域链的用途："><a href="#▷作用域链的用途：" class="headerlink" title="▷作用域链的用途："></a>▷作用域链的用途：</h4><p>保证该执行环境下有权访问的所有变量、函数的<strong>有序访问</strong>！</p><h4 id="▷作用域链搜索方法："><a href="#▷作用域链搜索方法：" class="headerlink" title="▷作用域链搜索方法："></a>▷作用域链搜索方法：</h4><p>目标标识符的解析是从执行环境的最前端开始，沿着作用域链一级一级向后回溯，直到找到标识符为止。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(color==<span class="string">"blue"</span>)&#123;</span><br><span class="line">color = <span class="string">"red"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">color = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br><span class="line"><span class="built_in">console</span>.log(color); <span class="comment">//red</span></span><br></pre></td></tr></table></figure><p>  以上代码解释了标识符<code>color</code>的搜索过程。在调用函数<code>changeColor（）</code>后，执行到<code>if</code>判定时需要用到变量<code>color</code>。于是在当前执行环境下先于函数内部作用域搜索变量<code>color</code>；未找到后向外层检索，此时访问到了全局变量<code>color=&quot;blue&quot;</code>，<code>if</code>判定符合条件，执行颜色修改为<code>red</code>。</p><h4 id="▷作用域链访问不可逆。"><a href="#▷作用域链访问不可逆。" class="headerlink" title="▷作用域链访问不可逆。"></a>▷作用域链访问不可逆。</h4><p>整个搜索访问的过程中，可以通过作用域链从内部环境访问外部环境，但不可逆转，是<strong>线性有向</strong>的过程。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">anotherColor = color;</span><br><span class="line">color = tempColor;</span><br><span class="line"><span class="comment">//这里可以访问color、anotherColor和tempColor</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里可以访问color和anotherColor</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里只能访问color</span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure></p><p>以上代码中，<code>全局环境</code>、<code>changgeColor()</code>和<code>swapColor()</code>为三个不同的执行环境，<strong>可以由内层向外层搜索访问，但不可向内层访问</strong>。</p><h4 id="★JavaScript没有块级作用域"><a href="#★JavaScript没有块级作用域" class="headerlink" title="★JavaScript没有块级作用域"></a>★JavaScript没有块级作用域</h4><blockquote><p>JavaScript与其它语言不同的一点是，没有<strong>块级作用域</strong>。<br>块级作用域：<strong>由花括号封闭的代码块都有自己的作封闭执行环境（作用域）。</strong></p></blockquote><blockquote><p>JavaScript中只有<strong>函数</strong>具有类似块级作用域的函数作用域。<br>其它<code>if、for、while等</code>具有花括号的语句则没有块级作用域，也即<strong>语句执行结束后，内部变量、函数仍可以在外层执行环境中访问到！</strong> </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i;i&lt;<span class="number">10</span>;i++) &#123;                     ------<span class="keyword">for</span>示例</span><br><span class="line">    dosomething(i);</span><br><span class="line">&#125;</span><br><span class="line">alert(i);    <span class="comment">//10</span></span><br><span class="line"><span class="comment">//依旧可以访问i</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;                                  ------<span class="keyword">if</span>示例</span><br><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(color);  <span class="comment">//"blue"</span></span><br><span class="line"><span class="comment">//同样可以访问到color</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;                         ------<span class="function"><span class="keyword">function</span>示例</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">sum</span> = <span class="title">a</span>+<span class="title">b</span>;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">sum</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">result</span> = <span class="title">add</span>(<span class="params"><span class="number">10</span>,<span class="number">20</span></span>);</span></span><br><span class="line"><span class="function"><span class="title">alert</span>(<span class="params">sum</span>);      //<span class="title">error</span>:<span class="title">sum</span> <span class="title">is</span> <span class="title">not</span> <span class="title">defined</span></span></span><br></pre></td></tr></table></figure><h2 id="二、作用域习题测试"><a href="#二、作用域习题测试" class="headerlink" title="二、作用域习题测试"></a>二、作用域习题测试</h2><h3 id="1-纯作用域、作用域链类"><a href="#1-纯作用域、作用域链类" class="headerlink" title="1.纯作用域、作用域链类"></a>1.纯作用域、作用域链类</h3><p>1.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> z = <span class="number">30</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">console</span>.log(x + y + z);</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    bar()</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p><p>代码的输出结果为”60″。<strong>函数bar可以直接访问”z”，然后又通过作用域链访问上层<br>的”x”和”y”。</strong></p><p>2.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">'global'</span>;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(x)&#123;  </span><br><span class="line">        <span class="keyword">var</span> y =<span class="string">'local'</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> y;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(test(<span class="literal">true</span>)); <span class="comment">//local</span></span><br></pre></td></tr></table></figure></p><p>在当前作用域（<code>test（）</code>函数）内，可以找到目标标识符<code>y</code>，因此不需要向上访问全局变量<code>y=“global”</code>。</p><p>3.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">'global'</span>;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>)</span>&#123;  </span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(x)&#123;  </span><br><span class="line">            <span class="keyword">var</span> y = <span class="string">'local'</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;)();  </span><br><span class="line">    <span class="keyword">return</span> y;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(test(<span class="literal">true</span>));  <span class="comment">//global</span></span><br></pre></td></tr></table></figure></p><p>在当前作用域（<code>test（）</code>函数）内，找不到标识符<code>y</code>，因此按照向上搜索的规则，沿着作用域链访问全局变量<code>y=“global”</code>。<br>★<strong>不能向内层访问自执行函数中的y</strong></p><p>4.★★★★函数嵌套类<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> alert(a);</span><br><span class="line">&#125;;            </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">20</span>;</span><br><span class="line">aaa();</span><br><span class="line">&#125;</span><br><span class="line">bbb();   <span class="comment">//10</span></span><br></pre></td></tr></table></figure></p><p>因为<code>bbb（）</code><strong>访问不了内层作用域</strong>的变量<code>a</code>，因此向上访问全局变量<code>a = 10</code>.<br><strong>我们一步步来分析这个过程：</strong><br>先看个简单的：若果aaa本身就有，肯定拿自己的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>) </span>&#123;                 <span class="comment">//step-4</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">30</span>;</span><br><span class="line">alert(a);                    <span class="comment">//step-5-&gt;执行alert，此时最先找到aaa作用域下的a=30</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>) </span>&#123;                 <span class="comment">//step-2</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">aaa();                      <span class="comment">//step-3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义了函数没啥用，调用才是真格的所以这里是step-1</span></span><br><span class="line">bbb();        <span class="comment">//30              //step-1</span></span><br></pre></td></tr></table></figure></p><ul><li><p>假如aaa（）内未定义a呢，会取谁？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>) </span>&#123;                 <span class="comment">//step-4</span></span><br><span class="line">alert(a);                    <span class="comment">//step-5-&gt;执行alert，此时最先找到aaa的父作用域中的a=10</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>) </span>&#123;                 <span class="comment">//step-2</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">aaa();                      <span class="comment">//step-3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义了函数没啥用，调用才是真格的所以这里是step-1</span></span><br><span class="line">bbb();        <span class="comment">//10              //step-1</span></span><br></pre></td></tr></table></figure></li><li><p>要是全局的var a=10都没有呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>) </span>&#123;                 <span class="comment">//step-4</span></span><br><span class="line">alert(a);                    <span class="comment">//step-5-&gt;执行alert，此时沿着作用域一层一层找，没有a，所以报错。</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>) </span>&#123;                 <span class="comment">//step-2</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">aaa();                      <span class="comment">//step-3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义了函数没啥用，调用才是真格的所以这里是step-1</span></span><br><span class="line">bbb();        <span class="comment">//10              //step-1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="★★注意："><a href="#★★注意：" class="headerlink" title="★★注意："></a>★★注意：</h4><blockquote><p>函数作用域的嵌套关系是<strong>定义时决定</strong>的,而不是调用时决定的,也就是说,JavaScript 的作用域是<strong>静态作用域,又叫词法作用域,</strong>这是因为作用域的嵌套关系可以在语法分析时确定,而不必等到运行时确定。<br>具体可参看<a href="http://blog.csdn.net/wrian_ban/article/details/51601733" target="_blank" rel="noopener">这篇文章</a></p></blockquote><p>放在我们上面的<strong>实例中理解</strong>就是：aaa和bbb函数作用域是兄弟作用域，互相不能访问内部变量，这在定义的时候就确定了。虽然调用的时候，aaa是在bbb函数的内部调用，但是作用域链却不会被改变！<br>★5. <strong>a=b=10</strong>类特殊情况<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> a=b=<span class="number">10</span>; </span><br><span class="line">&#125;</span><br><span class="line"> aaa();</span><br><span class="line"> alert(a);<span class="comment">//结果为,无法访问到</span></span><br><span class="line"> alert(b);<span class="comment">//结果为10；</span></span><br></pre></td></tr></table></figure></p><p><code>var a=b=10;</code> 可以解析成 <code>b=10；var a=b;</code> 也就是b为<strong>全局</strong>变量，a为<strong>局部</strong>变量，所以外部访问a访问不到，访问b结果为10；</p><h3 id="2-作用域-变量-函数-提升类（笔试面试最爱！）"><a href="#2-作用域-变量-函数-提升类（笔试面试最爱！）" class="headerlink" title="2.作用域+变量(函数)提升类（笔试面试最爱！）"></a>2.作用域+变量(函数)提升类<mark>（笔试面试最爱！）</mark></h3><p>1.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">'global'</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(y);                <span class="comment">//undefined  </span></span><br><span class="line">    <span class="keyword">if</span>(x)&#123;  </span><br><span class="line">        <span class="keyword">var</span> y = <span class="string">'local'</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> y;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test(<span class="literal">true</span>));           <span class="comment">//local</span></span><br></pre></td></tr></table></figure></p><p>这里涉及到JavaScript中的<strong>变量提升</strong>，JavaScript中会自动把变量声明的语句提升到<strong>当前作用域</strong>的最前方 。<br>以上代码可以这样来理解 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">'global'</span>;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> y;                   <span class="comment">//声明提前了</span></span><br><span class="line">    <span class="built_in">console</span>.log(y);  </span><br><span class="line">    <span class="keyword">if</span>(x)&#123;  </span><br><span class="line">        y = <span class="string">'local'</span>;        <span class="comment">//赋值仍留着原地</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> y;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(test(<span class="literal">true</span>));   <span class="comment">//local</span></span><br></pre></td></tr></table></figure><p>当test函数中打印y时，变量y只是被声明了，并没有赋值，所以先打印出了undefined；<br>当程序继续向下执行，则将local返回出来。<br>2.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">//10  </span></span><br><span class="line">    <span class="keyword">return</span>;  </span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">100</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">b();  </span><br><span class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>变量<code>a</code>先是全局声明，在调用<code>b()</code>函数时，在内部又声明了局部的a变量（因为<code>var a=100</code>变量提升），改变其值为<code>10</code>.在执行完毕后，退出函数环境，局部的a变量销毁，因此访问到的a为全局的<code>1</code>。<br>4.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testResult</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span> * a;    </span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">200</span>;    </span><br><span class="line">  <span class="keyword">var</span> c = a / <span class="number">2</span>;    </span><br><span class="line">  alert(b);    </span><br><span class="line">  alert(c);    </span><br><span class="line">&#125;    </span><br><span class="line">testResult()        <span class="comment">//NaN  100</span></span><br></pre></td></tr></table></figure></p><p>同样是基于<strong>变量声明提前</strong>，原理参考<strong>第1题</strong>过程。局部变量a在函数中声明提前到第一行，值为<code>undefined</code>。因此b值为<code>NaN</code>,在a赋值后，c值为100。</p><p>5.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br></pre></td></tr></table></figure></p><p>这个例子同时涉及到了<strong>变量声明提升</strong>和<strong>函数声明提升</strong>。<br>上例等同于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName;    <span class="comment">//变量声明提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//函数声明提升到顶部</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//变量赋值依然保留在原来的位置</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName();    <span class="comment">// 最终输出：2</span></span><br></pre></td></tr></table></figure></p><p>由于<strong>变量和函数</strong>声明均提升到顶部，因此getName又被后面函数表达式的赋值操作给覆盖了，所以<strong>输出2</strong><br><strong>而如果将上代码稍加改动，变这样的话：</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getName();  <span class="comment">//最终输出：1</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>等同于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName;    <span class="comment">//变量声明提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//函数声明提升到顶部</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName();    <span class="comment">// 最终输出：1</span></span><br><span class="line"></span><br><span class="line">getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//变量赋值依然保留在原来的位置</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，有些人可能会觉得，当存在两个相同的声明，是不是由于覆盖的现象？造成了上面的结果？<br>那么接下来我们研究一下，到底两者共存遵循什么<strong>规律</strong>。<br>比如，有下述代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = funtion () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">// f a() &#123;console.log(10)&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a());  <span class="comment">// 10 和 undefined</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)   <span class="comment">//3</span></span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a());   <span class="comment">//a() is not a function;</span></span><br></pre></td></tr></table></figure></p><p>从结果我们可以看到：首先变量a提升到顶部，然后给它赋值一个函数，此时打印a，a为函数。后面进行了赋值3操作后，a变为3，此时再执行a（），浏览器会提示我们出错了。也就是说此时a又被覆盖为一个变量，而非函数。<br>a的变化过程如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;                  <span class="comment">//变量提升a=undefined</span></span><br><span class="line">a =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span>);    <span class="comment">//a赋值一个函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = <span class="number">3</span>;                 <span class="comment">//a赋值一个变量</span></span><br><span class="line">a = <span class="number">6</span>;</span><br></pre></td></tr></table></figure></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="1-同时出现变量提升和函数提升时，函数会首先被提升，然后才是变量。"><a href="#1-同时出现变量提升和函数提升时，函数会首先被提升，然后才是变量。" class="headerlink" title="1.同时出现变量提升和函数提升时，函数会首先被提升，然后才是变量。"></a>1.同时出现<strong>变量提升和函数提升时</strong>，函数会首先被提升，然后才是变量。</h4><h4 id="2-函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。"><a href="#2-函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。" class="headerlink" title="2.函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。"></a>2.函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。</h4><p>详细内容可以参看：书籍《你不知道的JavaScript》</p><h2 id="三、延长、扩展作用域"><a href="#三、延长、扩展作用域" class="headerlink" title="三、延长、扩展作用域"></a>三、延长、扩展作用域</h2><h3 id="1-延长作用域链"><a href="#1-延长作用域链" class="headerlink" title="1.延长作用域链"></a>1.延长作用域链</h3><blockquote><p>实现原理：在作用域链的前端增加一个<strong>变量对象</strong>，当执行流进入<strong>下列语句</strong>时，作用域链就得到加长：</p><ul><li><code>try-catch</code>语句的<code>catch</code>块</li><li><code>with</code>语句</li></ul></blockquote><p>1.对于<code>with</code>语句来说，会将指定的对象添加到作用域链中。<br>2.对于<code>catch</code>语句来说，会创建一个新的变量对象。</p><p>例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alterUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(location) &#123;</span><br><span class="line"><span class="keyword">var</span> url = href + qs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>with语句接收<code>location</code>对象，等同于with语句的作用域链扩展添加了location对象作用域部分。<br>因此，在with语句中可以调用所有的location对象的属性和方法。此时的href默认将获取浏览器的href，无需赋值。</p><h3 id="2-扩展作用域"><a href="#2-扩展作用域" class="headerlink" title="2.扩展作用域"></a>2.扩展作用域</h3><p>扩展作用域的方法常用有两种：</p><ul><li><code>call（）</code>方法</li><li><p><code>apply（）</code>方法</p><h4 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h4><blockquote><p><code>call</code>和<code>apply</code>方法是函数本身具有的<strong>非继承</strong>的方法，不仅可以<strong>传递参数</strong>，还可以扩充函数运行的<strong>作用域</strong>。</p></blockquote><p>★<code>apply（）</code>方法能劫持另外一个对象的方法，继承另外一个对象的属性.  </p><blockquote><p>Function.apply(obj,args)`方法接收两个参数： </p><pre><code>**obj：**这个对象将代替Function类里this对象  **args：**这个是数组，可以是Array，也可以是arguments对象。总之它将作为参数传给    Function（args--&gt;arguments）</code></pre></blockquote><p>★ <code>call:</code>和apply的意思一样,只不过是将<strong>参数数组</strong>改为了<strong>参数列表</strong>.  </p><blockquote><p>Function.call(obj,[param1[,param2[,…[,paramN]]]]) </p><pre><code>**obj：**这个对象将代替Function类里this对象.**params：**这个是一个参数列表.</code></pre></blockquote></li></ul><p>示例：<br>1.<code>call()</code>:<br>（1）不传递参数，只改变<code>this</code>指向，以扩充作用域。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span>;</span><br><span class="line">       <span class="built_in">document</span>.color = <span class="string">'yellow'</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> s1 = &#123;<span class="attr">color</span>: <span class="string">'blue'</span> &#125;;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       changeColor.call();         <span class="comment">//red (默认传递参数为window对象参数)</span></span><br><span class="line">       changeColor.call(<span class="built_in">window</span>);   <span class="comment">//red</span></span><br><span class="line">       changeColor.call(<span class="built_in">document</span>); <span class="comment">//yellow</span></span><br><span class="line">       changeColor.call(<span class="keyword">this</span>);     <span class="comment">//red</span></span><br><span class="line">       changeColor.call(s1);       <span class="comment">//blue</span></span><br></pre></td></tr></table></figure></p><p>★（2）call的<strong>参数列表必须一一对应</strong>，否则将会出现赋值交叉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">food</span>(<span class="params">name,price</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fruits</span>(<span class="params">name,price,weight</span>)</span>&#123;</span><br><span class="line">food.call(<span class="keyword">this</span>,name,price,weight);</span><br><span class="line"><span class="keyword">this</span>.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> fruits(<span class="string">"pingguo"</span>,<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">alert(result.name+<span class="string">"--"</span>+result.price+<span class="string">"--"</span>+result.weight);   <span class="comment">//pingguo--5--2</span></span><br></pre></td></tr></table></figure><p>以上代码参数列表与food的变量顺序是保持一致。如果将参数列表顺序打乱(或者food函数参数顺序打乱)，就会出现赋值交叉的情况，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">food</span>(<span class="params">name,price</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fruits</span>(<span class="params">name,price,weight</span>)</span>&#123;</span><br><span class="line">food.call(<span class="keyword">this</span>,price,name,weight);</span><br><span class="line"><span class="keyword">this</span>.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> fruits(<span class="string">"pingguo"</span>,<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">alert(result.name+<span class="string">"--"</span>+result.price+<span class="string">"--"</span>+result.weight);  <span class="comment">//5--pingguo--2</span></span><br></pre></td></tr></table></figure></p><p>2.<code>apply()</code>:<br>（1）不传递参数，只改变<code>this</code>指向，扩展作用域<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.number = <span class="string">'one'</span>;</span><br><span class="line"><span class="built_in">document</span>.number = <span class="string">'two'</span>;</span><br><span class="line"><span class="keyword">var</span> s1 = &#123;<span class="attr">number</span>: <span class="string">'three'</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor.apply();         <span class="comment">//one (默认传参为window对象下参数)</span></span><br><span class="line">changeColor.apply(<span class="built_in">window</span>);   <span class="comment">//one</span></span><br><span class="line">changeColor.apply(<span class="built_in">document</span>); <span class="comment">//two</span></span><br><span class="line">changeColor.apply(<span class="keyword">this</span>);     <span class="comment">//one</span></span><br><span class="line">changeColor.apply(s1);       <span class="comment">//three</span></span><br></pre></td></tr></table></figure></p><p>（2）函数间作用域扩展，实现方法调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;                <span class="comment">//定义一个人类</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,grade</span>)</span>&#123;        <span class="comment">//定义一个学生类</span></span><br><span class="line">Person.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);        <span class="comment">//扩展Student的作用域到Person。</span></span><br><span class="line"><span class="comment">//或者Person.call(this,name,age); 也可实现作用域扩展！</span></span><br><span class="line"><span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> student1 = <span class="keyword">new</span> Student(<span class="string">"xiaowang"</span>,<span class="number">21</span>,<span class="number">90</span>);</span><br><span class="line">alert(student1.name+student1.age+student1.grade); <span class="comment">//xiaowang2190</span></span><br></pre></td></tr></table></figure></p><p>详细的扩展作用域的方法解析，可以参看这篇文章：<a href="http://blog.csdn.net/Little_ChenH/article/details/79488393" target="_blank" rel="noopener">call，apply，bind改变this指向</a></p><p>参考文章书籍：<br>JavaScript高级程序设计-第四章<br><a href="https://juejin.im/entry/57f5d492bf22ec006475238f" target="_blank" rel="noopener">深入了解JavaScript，从作用域链开始（1）</a><br> <a href="http://www.cnblogs.com/hfxm/p/5547922.html" target="_blank" rel="noopener">JS作用域面试题总结 </a>                     </p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;一、涉及概念、知识点&quot;&gt;&lt;a href=&quot;#一、涉及概念、知识点&quot; class=&quot;headerlink&quot; title=&quot;一、涉及概念、知识点&quot;&gt;&lt;/a&gt;一、涉及概念、知识点&lt;/h2&gt;&lt;h3 id=&quot;1-执行环境&quot;&gt;&lt;a href=&quot;#1-执行环境&quot; class=&quot;headerlink&quot; title=&quot;1.执行环境&quot;&gt;&lt;/a&gt;1.执行环境&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;执行环境&lt;/strong&gt;定义了变量或者函数有权访问的其他数据，执行环境有与之相关联的变量对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行环境&lt;/strong&gt;会在环境内所有代码执行完毕后，销毁该环境。（全局执行环境会等到应用程序退出或者浏览器窗口关闭才会销毁）
    
    </summary>
    
      <category term="JS作用域详解" scheme="http://yoursite.com/categories/JS%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="JS作用域详解" scheme="http://yoursite.com/tags/JS%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
</feed>
