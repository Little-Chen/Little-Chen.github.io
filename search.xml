<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ajax跨域]]></title>
    <url>%2F2018%2F03%2F23%2FAjax%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[什么是跨域？ 一般来说，当一个请求url的协议、域名、端口三者之间任意一个与当前页面地址不同即为跨域。最常见的就是在一个域名下的网页中，调用另一个域名中的资源。 当浏览器报这样的错的时候，就是跨域请求出问题了！ 从根源上讲，跨域是由浏览器安全的同源策略引起的！ 同源策略是由Netscape提出的著名安全策略，是浏览器最核心、基本的安全功能,它限制了一个源(origin)中加载文本或者脚本与来自其他源(origin)中资源的交互方式。 所谓的同源就是指的：协议、域名、端口相同。 当浏览器执行一个脚本时会检查是否同源，只有同源的脚本才会执行，如果不同源即为跨域。同源策略是出于安全考虑对js进行限制，防止恶意用户获取非法数据，同时还防止了大部分XSS攻击（就是向用户界面注入js脚本）。通常跨域是由以下两种同源策略造成的 DOM同源策略。禁止对不同源的页面的DOM进行操作，主要包括iframe、canvas之类的。不同源的iframe禁止数据交互的，含有不同源数据的canvas会受到污染而无法进行操作。 XmlHttpRequest同源策略。简单来说就禁止不同源的AJAX请求。 解决跨域的方法jsonp首先，我们需要认知： jsonp是一种非正式协议。 scrpit的src属性不受同源限制，有跨域请求的能力！（img也不受限制） jsonp通过script的src属性引入一个js文件，并返回一个js函数的调用！总的来说就是利用了script标签不受同源策略的限制去获取数据。这就是jsonp的原理。具体操作流程为： 动态创建script标签。 绑定src路径到想访问的地址。 添加到document.body.appendChild()中！ 通过函数声明，进行你想进行的数据操作。 一个简单的jsonp12345678function fun(data) &#123; //回调函数 console.log(data); //对数据的处理&#125;;var body = document.getElementsByTagName(&apos;body&apos;)[0];var script = document.gerElement(&apos;script&apos;);script.type = &apos;text/javasctipt&apos;;script.src = &apos;http://example.com?jsonp=cb&apos;;body.appendChild(script); 实例： 百度搜索框！以下为搜索关键字wd=apple时 https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=apple&amp;cb=abc js返回的结构： abc({q:”apple”,p:false,s:[“apple中国官方网站”,”apple中国”,”apple store官网”,”apple id”,”apple pay”,”apple pay 5折”,”apple watch”,”apple developer”,”apple id注册”,”apple pay如何使用”]});123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;Author&quot; content=&quot;FengYu&quot;&gt; &lt;title&gt;Tz-36期Js&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; font-family: Microsoft YaHei, serif; &#125; li &#123; list-style: none; &#125; #box &#123; width: 400px; margin: 50px auto; &#125; input &#123; width: 398px; height: 35px; border: 1px solid #ddd; &#125; ul &#123; width: 398px; border: 1px solid #666; cursor: pointer; &#125; ul li &#123; line-height: 30px; text-indent: 10px; &#125; ul li:hover &#123; background: #888; color: #fff; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;ul&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var Ul = document.getElementsByTagName(&quot;ul&quot;)[0], input = document.getElementsByTagName(&quot;input&quot;)[0]; //https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&quot;+val+&quot;&amp;cb=abc 百度的js搜索文件 input.oninput = function() &#123; var val = this.value; var script = document.createElement(&quot;script&quot;); script.src = &quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&quot; + val + &quot;&amp;cb=abc&quot;; document.body.appendChild(script); script.onload = function() &#123; document.body.removeChild(this) &#125; &#125; function abc(obj) &#123; var arr = obj.s; Ul.innerHTML = &quot;&quot;; for(var i in arr) &#123; Ul.innerHTML += &apos;&lt;li&gt;&apos; + arr[i] + &apos;&lt;/li&gt;&apos; &#125; &#125; //事件代理 Ul.onclick = function(e) &#123; var This = e.target; //事件源 if(/li/i.test(This.nodeName)) &#123; window.open(&quot;https://www.baidu.com/s?wd=&quot; + This.innerHTML) &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 总结： 这种方法所有浏览器都兼容，前端可以很轻松的做到跨域请求，但也有一些缺点： 只能通过GET方式请求，一方面是参数长度有限制，二是安全性比较差； 只能通过js传回数据！ 后端需要知道前端的abc是什么样的结构，主要在参数和回调函数名,并进行相应配置； 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 CORS（跨域资源共享）概念：Cross-Origin Resource Sharing(跨域资源共享)是一个W3C标准，它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 在分析CORS之前，还需要了解一下ajax跨域报错产生的过程。 使用XMLHttpRequest发送数据请求时，浏览器如果发现违反了同源策略（跨域请求资源时）就会自动在请求头（Request Header）中加上一个字段:origin。此字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。 服务器CORS端会根据这个源的值，判断是否在许可范围，若不符合返回的HTTP响应头（Response Header）信息则会缺少Access-Control-Allow-Origin项，从而抛出一个错误。如同文章开头我们看到的那样！ 也就是说，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，将目标源纳入许可范围，就可以跨源通信。当origin的url值在许可范围内，服务器会返回包含以下头信息字段。123Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBar 随后，浏览器检测到 Access-Control-Allow-Origin 项 就可以允许Ajax进行跨域的访问。简单CORS跨域例子：平时的ajax请求可能是这样的:12345&lt;script type=&quot;text/javascript&quot;&gt; var xhr = new XMLHttpRequest(); xhr.open(&quot;POST&quot;, &quot;/damonare&quot;,true); xhr.send();&lt;/script&gt; 以上damonare部分是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：12345&lt;script type=&quot;text/javascript&quot;&gt; var xhr = new XMLHttpRequest(); xhr.open(&quot;￼GET&quot;, &quot;http://segmentfault.com/u/trigkit4/&quot;,true); xhr.send();&lt;/script&gt; 总结： 现代浏览器中和移动端都支持CORS（除了opera mini），IE下最好10+ CORS支持所有类型的HTTP请求。 CORS更为先进和方便，但需要服务器端进行处理。 通过HTML5的postMessagewindow.postMessage属于html5的新特性 这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。比如damonare.cn域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信！ A页面通过postMessage方法发送消息： 12345window.onload = function() &#123; var ifr = document.getElementById(&apos;ifr&apos;); var targetOrigin = &quot;http://www.google.com&quot;; ifr.contentWindow.postMessage(&apos;hello world!&apos;, targetOrigin); &#125;; postMessage的使用方法： otherWindow.postMessage(message, targetOrigin);- `otherWindow`:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口 - `message`: 是要发送的消息，类型为 String、Object (IE8、9 不支持) - `targetOrigin`: 是限定消息接收范围，不限制请使用 `*` B页面通过message事件监听并接受消息: 1234567891011121314var onmessage = function (event) &#123; var data = event.data;//消息 var origin = event.origin;//消息来源地址 var source = event.source;//源Window对象 if(origin==&quot;http://www.baidu.com&quot;)&#123; console.log(data);//hello world! &#125; &#125;; if (typeof window.addEventListener != &apos;undefined&apos;) &#123; window.addEventListener(&apos;message&apos;, onmessage, false); &#125; else if (typeof window.attachEvent != &apos;undefined&apos;) &#123; //for ie window.attachEvent(&apos;onmessage&apos;, onmessage); &#125; 同理，也可以B页面发送消息，然后A页面监听并接受消息。总结： postMessage非常适合进行页面间跨域通信 需要较高版本的浏览器，IE10+. 服务器代理可以在服务器端设置一个代理，由服务器端向跨域下的网站发出请求，再将请求结果返回给前端，成功避免同源策略的限制。最简单操作，给url加一个前缀即可！1&apos;https://bird.ioliu.cn/v1?url=&apos;+url（请求资源的地址） 通过window.name跨域window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。比如：我们在任意一个页面输入: 1234window.name = &quot;My window&apos;s name&quot;;setTimeout(function()&#123; window.location.href = &quot;http://damonare.cn/&quot;;&#125;,1000) 进入damonare.cn页面后我们再检测再检测 window.name :1window.name; // My window&apos;s name 可以看到，如果在一个标签里面跳转网页的话，我们的 window.name 是不会改变的。 例子：在 iframe.html 中设置好了 window.name 为我们要传递的字符串。我们在 index.html 中写了下面的代码，可实现跨页面传数据：123456789var iframe = document.getElementById(&apos;iframe&apos;);var data = &apos;&apos;;iframe.onload = function() &#123; iframe.onload = function()&#123; data = iframe.contentWindow.name; &#125; iframe.src = &apos;about:blank&apos;;&#125;; 总结 此方法适合进行页面间跨域通信！ 最后，还有一种偏门的方法，简单粗暴！ 关闭浏览器安全机制，仅在测试代码时使用。 解除浏览器安全审核，可以免去跨域操作,直接进行请求！1chrome.exe -disable-web-security -user-data-dir 参考文章：跨域资源共享跨域那些事跨域]]></content>
      <categories>
        <category>Ajax跨域</category>
      </categories>
      <tags>
        <tag>Ajax跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解HTTP笔记]]></title>
    <url>%2F2018%2F03%2F23%2F%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基础概念http协议，即超文本传输协议。为TCP/IP的一个子集。 TCP/IP协议族：包含HTTP协议。 TCP/IP的分层管理： 应用层：预存了各类应用服务，如：FTP、DNS 传输层：提供了计算机间的数据传输，如：TCP、UDP 网络层：处理网络上流动的数据包（数据的最小单位） 数据链路层：处理网络连接的硬件部分。 TCP/IP通信流程 发送客户端在应用层发出查看请求，传输层将接受到的数据（请求报文）进行分割，并以此标序后发给网络层。在网络层增加通信目的地的MAC地址后发送给链路层。 接收端在链路层收到数据，按照序号向上层发送，最终抵达应用层，服务器得到请求。 发送端在每层传输时，都会逐层打上首部信息。接收端则依次删去。 这种数据信息包装的做法叫做封装！IP、TCP、DNSIP协议 IP协议处在网络层，功能是实现数据包的传送。确保数据送达的两个重要条件是： IP地址和MAC地址。 IP地址：节点被分配到的地址。（可变） MAC地址：网卡所属的固定地址。（固定） ARP：一种解析地址的协议。可以通过IP地址查询相应MAC地址。 整个通信过程其实经历了很多次随机中转，称为路由选择。TCP协议 TCP协议位于传输层，提供字节流服务，确保可靠性。 即把大段的数据分割成为有序报文段，成为一个个数据包进行管理，使传输更稳定，可以传输更大体量的数据。 此外，为确保数据送达，TCP协议建立连接进行了三次握手。 1.首先发送端发送具有SYN（同步）标志的数据包，表示请求连接。 2.接受端收到后，回传一个SYN和ACK（确认）的数据包，表示确认收到。 3.发送端收到后再发送一个标有SYN的数据包，代表“握手结束”，连接已确认建立。 断开连接进行了四次握手 1.客户端主动关闭连接时，发送一个FIN给服务端，终止连接。 2.服务端受到后，回传一个ACK（确认）数据包，确认关闭信息。 3.过一会儿，服务器关闭后，发送一个FIN给客户端表示关闭。 4.客户端收到FIN给服务器发送ACK，表示确认收到关闭信息。连接中断。 SYN：同步序号，是TCP建立连接时使用的握手信号ack：接收端给发送端的一种传输类控制字符，表示发来的数据已确认接收无误FIN：TCP终止时使用的挥手信号 DNS协议 DNS位于应用层，是一个分布式数据库。提供域名到IP的解析服务。 DNS协议提供域名查找IP地址，或者逆向查询的服务。 以上参考了文章：TCP连接的建立与终止过程 URL/URI URI/URL： 统一资源标识符/统一资源定位符【URL是URI的子集！】 URL ：就是我们常使用的Web浏览器访问页面所要输入的网页地址。 URI格式:http:// user:pass @www.example.jp:80 /dir/index.htm ?uid=1#ch112345678http:// ①协议方案名user:pass ②登录信息www.example.jp ③服务器地址（域名）80 ④服务器端口号dir/index.htm ⑤文件路径?uid=1 ⑥查询字符串ch1 ⑦片段标识符1、3、5是必须属性！ 简单的HTTP协议HTTP简单通信过程 请求访问资源的称为客户端，提供资源响应的称为服务端。 请求报文1234567GET / index.htm HTTP/1.1Host: hackr.jpConnection: keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 16//空行name = ueno&amp;age=37 由请求访问服务器的类型方法，请求资源对象（request-URI），协议版本号，可选请求首部字段和内容实体构成。 响应报文1234567HTTP/1.1 200 OK Date: Tue , 10 jul 2012 06:50:15 GMTContent-Length: 362Content-Type: text/html//空行&lt;html&gt;... 由协议版本，状态码，状态码原因短语，响应首部字段和响应主体构成。 HTTP是无状态协议 HTTP是一种无状态协议：是为了更快速地处理大量事物，减少服务器资源消耗，确保协议可伸缩性而设计的。为了弥补无状态的缺点，引入了Cookie技术。 HTTP请求方法： GET：获取资源 POST：传输实体主体 PUT：传输文件（不带任何验证机制，不安全） HEAD：获取报文首部（通信状态）。 DELETE：删除文件 OPTION：询问支持的传输方法 TRACE：追踪路径 CONNECT：要求用隧道协议连接代理 等。。。 详见参考：http六种 请求方法 建立持久连接（HTTP keey-alive 或 HTTP connection reuse）保持TCP的状态。 管线化实现，并行发送多个请求，无需等待。 Cookie状态管理 通过在请求和响应报文中写入Cookie信息控制客户端状态。 响应报文返回一个Set-Cookie首部字段信息，保存在客户端。下次请求会自动添加到请求报文中发送。代码参见书P40 HTTP报文P43请求行、状态行。 范围请求：用首部字段Range指定资源的byte范围。如：1Range： bytes=5001-10000 //请求5001-10000字节的资源 HTTP请求状态码1xx 消息该类型的状态码代表请求已被接受，需要继续处理。 100 Continue 客户端应当继续发送请求，这个临时响应是用来通知客户端的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分。如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101 Switching Protocols 服务器已经理解客户端的请求，并通过 Update 消息头通知客户端采用不同的协议来完成这个请求。只有在切换新的协议更有好处时，才采取类似措施。 102 Procsessing 扩展状态码，代表处理将被继续执行。 2xx 成功该类型的状态码代表请求已成功被服务器接收、理解并接受。 200 OK(常用) 请求成功，请求所希望的响应头或数据体将随此响应返回。 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其 URL 已经随 Location 头信息返回。 202 Accepted 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。 203 Non-Authoritative Information 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。 204 No Content(常用) 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。该响应禁止包含任何消息体，始终以消息头后的第一个空行结束。 205 Reset Content 服务器成功处理了请求，且没有返回任何内容。与 204 不同之除在于，返回此状态码的响应要求请求者重置文档视图。该响应主要被用于接受用户输入后，立即重置表单，以便用户能够开始另一次输入。同样被禁止包含任何消息体。 206 Partial Content(常用) 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或迅雷这类 HTTP 下载工具，都是使用此类响应实现断点续传或将大文件分解为多段同时下载。 207 Multi-Status 扩展状态码，代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 3xx 重定向这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址 ( 重定向目标 )在本次响应的 Location 域中指明。仅当后续请求所使用的方法是 GET 或 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动检测无限循环重定向，否则会导致双端不必要的资源消耗。HTTP/1.0 版规范建议，浏览器不应超过 5 次重定向。 300 Multiple Choices 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息，用户或浏览器能够自行选择一个首选地址进行重定向。除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址列表的实体，以便用户或浏览器从中选择最合适的重定向地址。 301 Moved Permanently(常用) 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。 302 Found(常用) 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。 303 See other(常用) 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。该请求禁止被缓存。 304 Not Modified(常用) 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容自上次访问或根据请求的条件并没有改变，则服务器应当返回该状态码。304 响应禁止包含消息体。 305 Use Proxy 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在 URI 的信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应的资源。只有原始服务器才能创建 305 响应。 306 Switch Proxy 最新版规范中，已经废弃。 307 Temporary Redirect(常用) 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。 4xx客户端错误该类型的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。 400 Bad Request(常用) 由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 401 Unauthorized 当前请求需要用户验证。 402 Payment Required 预留 403 Forbidden(常用) 服务器已经理解请求，但是拒绝执行。 404 Not Found(常用) 请求失败，请求所希望得到的资源未被在服务器上发现。 405 Method Not Allowed 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 407 Proxy Authentication Required 与 401 响应类似，只不过客户端必须在代理服务器进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以身份询问。 408 Request Timeout 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可买随时再次提交这一请求而无需进行任何更改。 409 Conflict 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。 410 Gone 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。 411 Length Required 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。 412 Precondition Failed 服务器在验证请求的头字段中给出先决条件时，没能满足其中的一个或多个。 413 Request Entity Too Large 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或能够处理的范围。 414 Request-URI Too Long 请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。 415 Unsupported Media Type 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器所支持的格式，因此请求被拒绝。 416 Request Range Not Satisfiable 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回 406 状态码。 417 Expectation Failed 在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。 418 I’m a teapot 不需要定义，是一个玩笑，为愚人节制定的。 421 There are too many connections from your internet address 从当前客户端所在的 IP 地址到服务器的连接数超过了服务器的许可最大范围。通常，这里的 IP 地址指的是从服务器看到的客户端地址。这里的客户端不一定是终端用户。 422 Unprocessable Entity 请求格式正确，但是由于含有语义错误，无法响应。 423 Locked 当前资源被锁定。 424 Failed Dependency 由于之前的某个请求发生的错误，导致当前请求失败。 425 Unordered Collection 没正式使用。 426 Upgraed Required 客户端应当切换到 TLS/1.0。 449 Retry With 由微软扩展，代表请求应当在执行完适当的操作后进行重试。 451 Unavailable For Legal Reasons 由 IETF 核准，代表访问因法律的要求被拒绝。 5xx 服务器错误该类型的状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。 500 Internal Server Error(常用) 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来讲，会出在服务器程序代码出错时出现。 501 Not Implemented 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 502 Bad Gateway 作为网关或代理工作的服务器尝试执行请求时，从上游服务器收到无效的响应。 503 Service Unavailable(常用) 由于临时的服务器维护或过载，服务器当前无法处理请求。 504 Gateway Timeout 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器或者辅助服务器收到响应。注意：某些代理服务器在 DNS 查找超时时会返回 400 或者 500 错误。 505 HTTP Version Not Supported 服务器不支持，或者拒绝支持在中使用的 HTTP 版本。这暗示着服务器不能或不愿意与客户端相同的版本。 506 Variant Also Negotiates 由《透明内容协商协议》扩展，代表服务器存在内部配置错误。 507 Insufficient Storage 服务器无法存储完成请求所必须的内容。 509 Bandwidth Limit Exceeded 服务器达到带宽限制。这不是一个官方的状态吗，但仍被广泛使用。 510 Not Extended 获取资源所需要的策略并没有被满足。 web服务器 虚拟主机：实现了一台HTTP服务器搭建多个web站点。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的面向对象（OOP）]]></title>
    <url>%2F2018%2F03%2F23%2FJS%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88OOP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[什么是面向对象？概念 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 万事万物皆对象。面向对象的思想主要是以对象为主，将一个问题抽象出具体的对象，并且将抽象出来的对象和对象的属性和方法封装成一个类。 在 OOP 中，每个对象能够接收消息，处理数据和发送消息给其他对象。每个对象都可以被看作是一个拥有清晰角色或责任的独立小机器。面向对象和面向过程的区别？我们常提到的两种编程方式就是面向过程和面向对象，面向过程的有C，面向对象的有java、C#、C++、JavaScript等。面向对象和面向过程是两种不同的编程思想。举个例子形象说明一下：在面向过程的编程方式中实现“把大象放冰箱”这个问题答案是耳熟能详的，一共分三步： 开门（冰箱）； 装进（冰箱，大象）； 关门（冰箱）。 而面向对象中呢？ 冰箱.开门（） 冰箱.装进（大象） 冰箱.关门（） 总结： 面向过程的特点在于逻辑性强，符合思维方式和解决问题的流程。 面向对象的特点就是可扩展性更强一些，解决了代码重用性的问题。为什么要使用面向对象编程？我们知道，js中对象，对象下的方法和属性，都是储存在内存中的，调用的时候，是可以随时拿到这些属性和方法的。在编程中使用OOP就是为了提高代码的复用性，而提高代码复用性的根本原因是为了降低内存的使用率。举个简单的例子： 在同一个家里，只要有一把螺丝刀就可以了，大家都可以使用，而不是每人都配一把螺丝刀，这样没有必要，而且浪费家里的空间。在这个例子中，家就是内存，而每个人就是一个变量，螺丝刀是一个方法，如果很多人想用螺丝刀，那么就创建一个类，由这个类创建出多个实例，所有的实例都共用一个螺丝刀，而不是每个人一把螺丝刀，这样太浪费了。 面向对象程序设计的目的是在编程中促进更好的灵活性和可维护性，在大型软件工程中广为流行。即代码各部分相对独立，耦合性低，且功能明确，遇到bug或者更改需求，都可以直接针对特定的对象进行修改，便于维护。另外，面向对象凭借其对模块化的重视，面向对象的代码开发更简单，更容易理解，相比非模块化编程方法 , 它能更直接地分析, 编码和理解复杂的情况和过程。 面向对象相关术语术语 Namespace 命名空间允许开发人员在一个独特, 应用相关的名字的名称下捆绑所有功能的容器。 Class 类定义对象的特征。它是对象的属性和方法的模板定义. Object 对象类的一个实例。 Property 属性对象的特征，比如颜色。 Method 方法对象的能力，比如行走。 Constructor 构造函数对象初始化的瞬间, 被调用的方法. 通常它的名字与包含它的类一致. Inheritance 继承一个类可以继承另一个类的特征。 Encapsulation 封装一种把数据和相关的方法绑定在一起使用的方法. Abstraction 抽象结合复杂的继承，方法，属性的对象能够模拟现实的模型。 Polymorphism 多态多意为‘许多’，态意为‘形态’。不同类可以定义相同的方法或属性。实现面向对象编程面向对象有三大特性，封装、继承和多态封装封装主要实现的功能就是将数据隐藏，只暴露出有限的接口。在js中万物皆对象，字符串、数值、数组、函数都属于Object。因此js基本的创建对象的方法有两种： 对象字面量法 new对象123456789101112131415//对象字面量var person = &#123; name:&quot;chen&quot;, age：22， sayname:function ()&#123; alert(this.name); &#125;&#125;//new对象var person = new Obejct();person.name = &quot;chen&quot;;person.age = 22;person.sayname = function ()&#123; alert(this.name);&#125; 但这两种方法都会产生大量重复代码，基于面向对象思想，我们使用新的方式创建对象。 工厂模式工厂模式如同它的名字一般，将对象从原料加工、制作、最后出厂，可实现大批量的功能相似产品对象！123456789101112131415function createPerson(name)&#123; //1、原料 var obj=new Object(); //2、加工 obj.name=name; obj.showName=function()&#123; alert(this.name); &#125; //3、出场 return obj; &#125; var p1=createPerson(&apos;小米&apos;);var p1=createPerson(&apos;小红&apos;);p1.showName();//小米p2.showName();//小红 工厂模式的优缺点：虽然解决了创建相似对象的问题，但是却没有解决对象识别问题（即怎样知道一个对象的类型）。 构造函数模式构造函数其实就是普通的函数，只不过有以下的特点： 首字母大写（建议构造函数首字母大写，即使用大驼峰命名，非构造函数首字母小写） 内部使用this 使用 new生成实例123456789function Dog(name, age, job)&#123; this.varieties = varieties; this.age = age; this.sayName = function()&#123; alert(varieties, age); &#125;; &#125; var dog1 = new Dog(&quot;Husky&quot;, 2);var dog2 = new Dog(&quot;Alaska&quot;, 3); 其中new操作符内部会经以下四个步骤： 1、创建一个新对象；2、将构造函数的作用域赋给新对象（因此这个this就指向这个新对象）；3、执行构造函数中的代码（为这个新对象添加属性）；4、返回新对象。 构造函数模式的优缺点： 1、优点：创建自定义函数意味着将来可以将它的实例标识为一种特定的类型，这是构造函数胜过工厂模式的地方 2、缺点：每个方法都要在每个实例上重新创建一遍 原型(类)模式辨析prtotype、_proto_、constructor◆每一个构造函数，都有一个原型[[prototype]]属性 指向构造函数的原型对象◆每一实例化对象都有一个隐式原型proto 指向构造函数的原型对象◆每一个原型对象都有一个默认的constructor属性，指向对象的构造函数解释： 每个函数都有一个 prototype 属性，记住，只有函数才有，对象没有，而每个对象都会拥有一个 proto 属性（后面会对 proto 属性详细讲解）。因为在 JS 中，函数也是对象，所以，函数也会拥有一个 proto 属性。也就是说函数会同时拥有 prototype 和 proto 属性，而对象只有 proot 属性。 此外，每个由构造函数生成的实例都会拥有的是一个 [[prototype]]的属性，但是规范中并没有明确定义这样一个默认的属性，所以实际上是无法获取这个属性的，不过 FireFox, Safari, Chrome 都会支持通过 proto 来获取这个属性，所以才会有 proto 这样一个属性。也就是说 [[prototype]] == _ _proto__ 。 构造器作为一个普通函数，如上面所说，会拥有一个 prototype 的属性。这个 prototype 属性是个对象，这个对象就是原型对象（下文说原型对象都指的是这个对象）。原型对象会拥有很多属性和方法，而一旦使用 new 操作符调用构造器函数的时候，所有的实例就会拥有构造器函数的 prototype 属性上的所有属性和方法，也就是原型对象上的所有属性和方法，这样就实现了原型继承。 123456789101112131415161718192021222324&lt;script type=&quot;text/javascript&quot;&gt; // 1. 创建一个构造器 function Person() &#123;&#125; // 2. 创建一个构造器原型 Person.prototype.name = &apos;jizq&apos;; Person.prototype.age = 28; Person.prototype.sayName = function() &#123; console.log(this.name) &#125;; // 3. 由构造器创建两个实例 var p1 = new Person(), p2 = new Person(); p1.sayName(); // jizq p2.sayName(); // jizq // 4. 查看这两个实例之间的关系 console.log(p1.sayName == p2.sayName); // true // Problems with prototypes // 当一个属性包含的是一个引用值的时候，使用 prototype 会出现问题。例如： Person.prototype.friends = [&apos;Shelby&apos;, &apos;Court&apos;]; p1.friends.push(&apos;Van&apos;); console.log(p2.friends); // [&apos;Shelby&apos;, &apos;Court&apos;, &apos;Van&apos;] // 因为 friends 这个属性并不是存在在 p1 上，而是存在于 Person.prototype 上面。通常，实例需要拥有自己的属性。 &lt;/script&gt; p1.sayName 和 p2.sayName 是同一个 sayName。当通过 Person.prototype 来修改 sayName 属性的时候，所有的实例都会受到影响，因为所有的实例都是指向这个方法的。下图为网上最经典的原型链的图解：原型模式的优缺点： 1、优点：可以让所有的对象实例共享它所包含的属性和方法 2、缺点：原型中是所有属性都是共享的，但是实例一般都是要有自己的单独属性的。所以一般很少单独使用原型模式。 混合模式（常用作封装类）通过构造函数模式定义实例（私有）属性，而原型模式用于定义方法和共享的属性 123456789101112131415161718192021function Person (name,age)&#123;//定义私有属性 this.name = name; this.age = age;&#125;Person.prototype.sayname = function ()&#123;//定义公有属性 console.log(this.name) &#125;var person1 = new Person(&quot;chen&quot;,22);var person2 = new Person(&quot;qian&quot;,21);console.log(person1.age);//22console.log(person2.age);//21person1.sayname()//chenperson2.sayname()//qianconsole.log(person1.sayname===person2.sayname);//trueperson1.age = 26;//改变person1的属性和方法person1.sayname = function ()&#123;console.log(&quot;change&quot;)&#125;;console.log(person1.age);//26 console.log(person2.age);//21 person2不受影响person1.sayname()//changeperson2.sayname()//qian person2访问原型的方法，不受影响 继承类式继承（原型继承）所谓的类式继承就是使用的原型的方式，将方法添加在父类的原型上，然后子类的原型是父类的一个实例化对象。123456789101112131415161718function Person(name)&#123; this.name=name; this.className=&quot;person&quot; &#125;Person.prototype.getClassName=function()&#123; console.log(this.className)&#125;function Man()&#123;&#125;Man.prototype=new Person();//1//Man.prototype=new Person(&quot;Davin&quot;);//2var man=new Man;&gt;man.getClassName()&gt;&quot;person&quot;&gt;man instanceof Person&gt;true 其中最核心的一句代码是Man.prototype=new Person() ;这种继承方式下，所有的子类实例会共享一个父类对象的实例，这种方案最大问题就是子类无法通过父类创建私有属性。比如每一个Person都有一个名字，我们在初始化每个Man的时候要指定一个不同名字，然后子类将这个名字传递给父类，对于每个man来说，保存在相应person中的name应该是不同的，但是这种方式根本做不到。所以，这种继承方式，实战中基本不用！ 构造函数继承12345678910111213141516171819function Person(name)&#123; this.name=name; this.className=&quot;person&quot; &#125;Person.prototype.getName=function()&#123; console.log(this.name)&#125;function Man(name)&#123; Person.apply(this,arguments)&#125;var man1=new Man(&quot;Davin&quot;);var man2=new Man(&quot;Jack&quot;);&gt;man1.name&gt;&quot;Davin&quot;&gt;man2.name&gt;&quot;Jack&quot;&gt;man1.getName() //1 报错&gt;man1 instanceof Person&gt;true Person.apply(this,arguments)：子类的在构造函数里用子类实例的this去调用父类的构造函数，从而达到继承父类属性的效果。这样一来，每new一个子类的实例，构造函数执行完后，都会有自己的一份资源(name)，不过会造成 内存浪费。但是这种办法只能继承父类构造函数中声明的实例属性，并没有继承父类原型的属性和方法，所以就找不到getName方法，所以1处会报错。为了同时继承父类原型，从而诞生了组合继承的方式: 组合继承1234567891011121314151617function Person(name)&#123; this.name=name||&quot;default name&quot;; //1 this.className=&quot;person&quot; &#125;Person.prototype.getName=function()&#123; console.log(this.name)&#125;function Man(name)&#123; Person.apply(this,arguments)&#125;//继承原型Man.prototype = new Person();var man1=new Man(&quot;Davin&quot;);&gt; man1.name&gt;&quot;Davin&quot;&gt; man1.getName()&gt;&quot;Davin&quot; 组合式继承就是汲取两者的优点，即避免了内存浪费，又使得每个实例化的子类互不影响。 寄生组合继承组合式继承的方法固然好，但是会导致一个问题，父类的构造函数会被创建两次（call()，apply()的时候一遍，new的时候又一遍），所以为了解决这个问题，又出现了寄生组合继承。 也就是说，我们只需要先给父类的原型创建一个副本，然后修改子类constructor属性，最后在设置子类的原型就可以了！1234567891011121314151617function Person(name)&#123; this.name=name; //1 this.className=&quot;person&quot; &#125;Person.prototype.getName=function()&#123; console.log(this.name)&#125;function Man(name)&#123; Person.apply(this,arguments)&#125;//注意此处Man.prototype = Object.create(Person.prototype);var man1=new Man(&quot;Davin&quot;);&gt; man1.name&gt;&quot;Davin&quot;&gt; man1.getName()&gt;&quot;Davin&quot; 这里用到了Object.creat(obj)方法，该方法会对传入的obj对象进行浅拷贝。和上面组合继承的主要区别就是：将父类的原型复制给了子类原型。这种做法很清晰： 构造函数中继承父类属性／方法，并初始化父类。 子类原型和父类原型建立联系。 另外我们发现，Person和Man实例的constructor指向都是Person，当然，这并不会改变instanceof的结果，但是对于需要用到construcor的场景，就会有问题。所以一般我们会加上这么一句：1Man.prototype.constructor = Man 综合来看，es5下，这种方式是首选，也是实际上最流行的。 ES6 中的 class继承es6引入了class、extends、super、static12345678910111213141516171819202122232425262728class Person&#123; //static sCount=0 //1 constructor(name)&#123; this.name=name; this.sCount++; &#125; //实例方法 //2 getName()&#123; console.log(this.name) &#125; static sTest()&#123; console.log(&quot;static method test&quot;) &#125;&#125;class Man extends Person&#123; constructor(name)&#123; super(name)//3 this.sex=&quot;male&quot; &#125;&#125;var man=new Man(&quot;Davin&quot;)man.getName()//man.sTest()Man.sTest()//4输出结果：Davinstatic method test 最后再说一下 ES6 中 class 实现原型继承。ES6 中 class 其实是原型继承的语法糖而已！es6继承的不足: 不支持静态属性（除函数）。 class中不能定义私有变量和函数。class中定义的所有函数都会被放倒原型当中，都会被子类继承，而属性都会作为实例属性挂到this上。如果子类想定义一个私有的方法或定义一个private 变量，便不能直接在class花括号内定义，这真的很不方便！多态多态（Polymorphism）按字面的意思就是“多种状态”,在面向对象语言中，接口的多种不同的实现方式即为多态。可以解释为：同样的操作作用于不同对象上面，可以产生不同的解释和不同的运行结果。换句话说，，给不同对象发送统一消息的时候，这些对象会根据这个信息分别给出不同的反馈。下面看一个例子：12345678910111213141516171819202122function Person(name,age)&#123; this.name=name this.age=age&#125;Person.prototype.toString=function()&#123; return &quot;I am a Person, my name is &quot;+ this.name&#125;function Man(name,age)&#123; Person.apply(this,arguments)&#125;Man.prototype = Object.create(Person.prototype);Man.prototype.toString=function()&#123; return &quot;I am a Man, my name is&quot;+this.name;&#125;var person=new Person(&quot;Neo&quot;,19)var man1=new Man(&quot;Davin&quot;,18)var man2=new Man(&quot;Jack&quot;,19)&gt; person+&quot;&quot;&gt; &quot;I am a Person, my name is Neo&quot;&gt; man1+&quot;&quot;&gt; &quot;I am a Man, my name isDavin&quot;&gt; man1 false 总的来说，JavaScript的多态的思想实际上就是把“做什么”和“谁去做”分离开来，要实现这一点，归根结底就是解耦。 OOP 的典型案例实现一个js插件见另一篇文章： 参考文章：MDN面向对象JS中面向对象阮一峰js面向对象github 理解面向对象面向对象编程（最系统）JavaScript继承与多态]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call，apply，bind改变this指向]]></title>
    <url>%2F2018%2F03%2F22%2Fcall%EF%BC%8Capply%EF%BC%8Cbind%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91%2F</url>
    <content type="text"><![CDATA[推荐非常浅显易懂的一片文章，搭配代码实例，易于理解！this与call… 首先我们先要明确一点： this 永远指向最后调用它的那个对象！！！然后我们在看看这三种方法的异同： call()主动执行，第一个参数为this要指向的对象，函数执行需要的实参依次写在后面。 apply()主动执行，第一个参数为this要指向的对象，第二参数为一个数组(类数组)，数组里包含所有实参。 bind()也用来改变this的指向，但不会主动执行函数。传参方式同call。但是bind不兼容IE8 三种方法，当第一个参数传null或者空，undefined时，this均指向window。 apply： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.apply(a,[1,2]) // 3 call：123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125; &#125; var b = a.fn; b.call(a,1,2) // 3 bind：123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2)() // 3 常见的用法： 改变this指向，引入其他对象的方法、属性。 1234567891011121314151617181920212223function Person(name)&#123; this.name = name;&#125;Person.prototype = &#123; constructor: Person, showName: function()&#123; console.log(this.name); &#125;&#125;var person = new Person(&apos;qianlong&apos;);person.showName();var animal = &#123; name: &apos;cat&apos;&#125;// 1 callperson.showName.call(animal);// 2 applyperson.showName.apply(animal);// 3 bindperson.showName.bind(animal)();//均输出cat 转化函数的arguments为真正的数组。 1var arr = [].slice.apply(arguments) //可以将函数的参数类数组改变为数组形式，方便调用。 其余应用可参考此文章的应用部分包括： 求数组最大和最小值 伪数组转化为数组 数组追加 使用call、apply继承其他类的方法（推荐）]]></content>
      <categories>
        <category>JS核心</category>
      </categories>
      <tags>
        <tag>JS核心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F03%2F21%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端性能优化的常用方法减少HTTP请求个数整合图片，合并css及JS文件，或者采用lazyload技术进行优化。 避免repaint 和reflow重绘：元素样式改变，布局未变，不影响DOM结构。重排：DOM部分重新渲染。 解决办法：避免操作DOM的结构、尺寸和内容；或者对于需要频繁操作的元素采用absolute定位脱离文档层。 减少DOM的操作次数，整合多次DOM操作，尽量降低次数。避免循环操作DOM，性能开销太大。 JSON进行数据交互，体量小，无需特殊处理货工具包。使用CDN（内容分发网络）基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上 压缩图片和图片精灵使用浏览器缓存静态资源cache-control，设定缓存，expires设定缓存时间。 ###CSS为什么要放在头，而JS放在尾？浏览器在执行JavaScript代码时，不能同时做其它事情，即每次出现都会让页面等待脚本的解析和执行（不论JavaScript是内嵌的还是外链的），JavaScript代码执行完成后，才继续渲染页面。这个也就是JavaScript的阻塞特性。 现在浏览器为了更好的用户体验，渲染引擎会尝试尽快在屏幕上显示内容，它不会等到所有的HTMl元素解析之后在构建和布局dom树，所以部分内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。因此CSS放在头部可以有效减少白屏时间和存在的跳闪现象。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS迭代器与循环]]></title>
    <url>%2F2018%2F03%2F19%2FJS%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[map、eval、for…in、for…of、forEach最早的数组遍历方式1234var a = ["a", "b", "c"];for(var index = 0;index &lt; a.length;index++)&#123; console.log(a[index]);&#125; map定义和方法map理解为“映射”的意思，基本用法同forEach，为ES5新增属性方法。❤map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理的后值。❤map()方法按照原始数组元素顺序依次处理元素。 注意：map不会对空数组进行检测map不会改变原始数组处理函数必须有返回值，否则会映射成undefined。map使用语法： 1arr.map(function(currentValue，index，arr),thisValue) 参数: 处理函数（必须），下属参数依次为：当前值value，序号index，原数组arr。 thisValue(可选) ❤另外，由于map方法为ES5新增方法，不支持IE9以下浏览器。如果需要兼容，可用原型扩展。方法如下： 1234567891011if (typeof Array.prototype.map != "function") &#123; Array.prototype.map = function (fn, context) &#123; var arr = []; if (typeof fn === "function") &#123; for (var k = 0, length = this.length; k &lt; length; k++) &#123; arr.push(fn.call(context, this[k], k, this)); &#125; &#125; return arr; &#125;;&#125; jquery中map方法用法同原生且从 1.6 开始，该函数也支持遍历对象。它接受两个参数，分别是要处理的数组/对象和处理函数，其处理函数也接受键值和键名两个参数。 123456789101112131415161718192021222324252627/**** jQuery $.map() ****/// 筛选数组元素var arrTmp = [1,2,3,4,5];var bigNum = $.map(arrTmp,function(num)&#123; if(num&gt;2)&#123; return num; &#125;&#125;);// bigNum -&gt; [3,4,5]// 处理对象var person = &#123; jack:&#123;age:9&#125;, tom:&#123;age:20&#125;, bobo:&#123;age:30&#125;&#125;var oldMan = $.map(person,function(value,key)&#123; if(value.age&gt;26)&#123; return key; &#125;&#125;)// oldMan -&gt; ["bobo"] eval eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。 注意：strong text该方法只接受原始字符串作为参数，如果 string 参数不是原始字符串，那么该方法将不作任何改变地返回。例子： 12345678910&lt;script type="text/javascript"&gt;eval("x=10;y=20;document.write(x*y)")document.write(eval("2+2"))var x=10document.write(eval(x+17))&lt;/script&gt; ###1 forEach语法： 1[].forEach(function(value, index, array) &#123; // ... &#125;); forEach遍历数组，而不是遍历对象哦，而且在遍历的过程中不能被终止,必须每一个值遍历一遍后才能停下来.也就是说：你不能使用break来退出循环, 不能使用return语句来返回到外层 jquery中forEach注意其与jQuery的$.each类似，只不过参数正好是相反的！ 1$.each([], function(index, value, array) &#123; // ... &#125;); 2 for…in适合进行普通对象的遍历 for-in循环遍历对象的key，即键值对的键名。 特性如下： 方法遍历到的index（或key）类型为String，若无意间进行了字符串计算，会带来许多不便。 for-in循环会遍历对象的所有可枚举属性。什么意思呢？就是除了遍历数组元素之外，还会遍历：自定义属性，原型上的属性。 一般不推荐遍历数组，因为for in遍历顺序是随机的，适合进行普通对象的遍历。 12345678910var myArry =[1,2,3,4];myArry.desc ='four'; for(var value in myArry)&#123; //循环key console.log(value)&#125;//"0"//"1"//"2"//"3"//"desc" 注意这里添加上去的属性也被遍历出来了 for…in由于历史遗留问题，它遍历的实际上是对象的属性名称，一个Array数据也是一个对象，数组中的每个元素的索引被视为属性名称，所以我们可以看到使用for…in循环Array数组时，拿到的其实是每个元素的索引. PS:若要避免原型链上的属性也被遍历到，可采用hasOwnProperty()方法去过滤掉对象原型链上的属性。 for…offor-of循环适合遍历数组 循环遍历对象的值，即键值对的键值。 123456789var myArry =[1,2,3,4];myArry.desc ='four';for(var value of myArry)&#123; console.log(value)&#125;//1//2//3//4 特性如下： 这是最简洁、最直接的遍历数组元素的语法。 这个方法避开了for-in循环的所有缺陷，解决了forEach的不可中断问题。 for…of为ES6新增方法。 不推荐for…of遍历普通对象，实在需要用for…of遍历，可搭配Object.keys()实现。 代码如下： 12345678910111213var student=&#123; name:'wujunchuan', age:22, locate:&#123; country:'china', city:'xiamen', school:'XMUT' &#125;&#125;for(var key of Object.keys(student))&#123; //使用Object.keys()方法获取对象key的数组 console.log(key+": "+student[key]);&#125; 总结：for…in与for…of格式对比： 1234567for (var key in arr)&#123; console.log(arr[key]);&#125;for (var value of arr)&#123; console.log(value);&#125; 推荐在循环对象属性的时候，使用for…in,在遍历数组的时候的时候使用for…of。 for in是遍历键名，for of是遍历键值。 注意，for…of是ES6新引入的特性。修复了ES5引入的for…in的不足。 参考文章：forEach/for…in/for…of迭代器与for…of循环]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础笔记]]></title>
    <url>%2F2018%2F03%2F09%2FHTML%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[html基础笔记命名规范HTML是什么？◾超文本标记语言（Hypertext Markup Language，HTML）通过标签语言来标记要显示的网页中的各个部分。一套规则，浏览器认识的规则。 HTML结构 ◾&lt;!DOCTYPE html&gt; 告诉浏览器使用什么样的html或者xhtml来解析html文档作用：声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。◾&lt;html&gt;&lt;/html&gt;是文档的开始标记和结束标记。此元素告诉浏览器其自身是一个 HTML 文档，在它们之间是文档的头部&lt;head&gt;和主体&lt;body&gt;。◾&lt;head&gt;&lt;/head&gt;元素出现在文档的开头部分。&lt;head&gt;与&lt;/head&gt;之间的内容不会在浏览器的文档窗口显示，但是其间的元素有特殊重要的意义。◾&lt;title&gt;&lt;/title&gt;定义网页标题，在浏览器标题栏显示。◾&lt;body&gt;&lt;/body&gt;之间的文本是可见的网页主体内容 2017.10.30一、div布局基础 网页分层： 表现层 css 结构层 html 行为层 JS meta标签:关键字内容，提供网站相关信息给搜索引擎。常用作：提高排名，SEO（搜索引擎优化）权重 &lt;meta&gt;元素可提供有关页面的元信息（meta-information），针对搜索引擎和更新频度的描述和关键词 charset字符集编码方式 常用标签 p标签段落标签！ h1-h6标签h1：logo主标题！h2：区块标题！h3-h6依次向下。不要滥用h标签！ sub、sup下标上标 &lt;br/&gt;换行 &lt;hr/&gt;水平线 &lt;i&gt;斜体标签（&lt;em&gt;效果相同） &lt;b&gt;粗体文本 &lt;strong&gt;加粗&lt;strong&gt;标签和&lt;em&gt;标签一样，用于强调文本，但它强调的程度更强一些。不能滥用强调标签！ 有序列表：&lt;ol&gt;&lt;li&gt;嵌套 无序列表：&lt;ul&gt;&lt;li&gt;嵌套 常见属性用法： 1234&lt;ol type=&quot;1&quot; start=&quot;10&quot;&gt; &lt;li&gt;asd&lt;/li&gt;&lt;/ol&gt; //以数字为序号的，从10开始的有序列表 123456&lt;ul type=&quot;circle&quot;&gt; &lt;li&gt;123&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;333&lt;/li&gt;&lt;/ul&gt; //无序列表（circle空心圆、disc实心圆、square正方块） 自定义列表：&lt;dl&gt;&lt;dt&gt;&lt;dd&gt;嵌套使用 -`&lt;dt&gt;`标题 -`&lt;dd&gt;`列表项 &lt;img/&gt;图片标签1.src引入图片路径。2.alt替代文本，seo抓取关键字。3.title鼠标悬浮提示文字 background 简写属性在一个声明中设置所有的背景属性。可以设置如下属性： background-color //颜色 background-position //定位 background-size //大小 background-repeat //重复方式 background-origin background-clip background-attachment background-image //图片 ★★★★ background-attachment：fixed图片固定在窗口的固定位置。 &lt;a&gt;超链接标签 href属性：(1)填写域名跳转链接(2)填写下载或打开文件路径(3)填写#代表空链接 target属性窗口打开方式：(1)_self当前窗口跳转链接(2)_blank新窗口跳转链接 &lt;a&gt;做锚点：页面内指定节点跳转！1234567&lt;a href=&quot;#head&quot;&gt;点击跳转&lt;/a&gt;&lt;p id=&quot;head&quot;&gt;第一部分&lt;/p&gt;&lt;p&gt;第二部分&lt;/p&gt;&lt;p&gt;第三部分&lt;/p&gt;&lt;p&gt;第四部分&lt;/p&gt;//点击即可跳转到第一部分！ 扩展： 1234567//锚链接滑动跳转效果$(&apos;a&apos;).click(function() &#123; $(&apos;html, body&apos;).animate(&#123; scrollTop: $($.attr(this, &apos;href&apos;)).offset().top &#125;, 5000); return false;&#125;); css样式引入方式： 行内样式 1&lt;div style=&quot;width:100px;height:200px;&quot;&gt;盒子&lt;/div&gt; 内嵌式 1234 &lt;style&gt;#a&#123;样式&#125;;.b&#123;样式&#125;; &lt;/style&gt; 链接式在&lt;head&gt;&lt;/head&gt;内写入： 1&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; 导入式（不建议使用）导入样式和链接样式比较相似，采用@import样式导入CSS样式表，在HTML初始化时，会被导入到HTML或者CSS文件中，成为文件的一部分，类似第二种内嵌样式。123&lt;style type=&quot;text/css&quot;&gt;@(培训)[标签1, 标签2, 标签3];&lt;/style&gt; 四种CSS引入方式的优先级 就近原则 理论上：行内&gt;内嵌&gt;链接&gt;导入 实际上：内嵌、链接、导入在同一个文件头部，谁离相应的代码近，谁的优先级高 color样式： 颜色或#xxxxxx rgb(x,x,x,x)前三个为三原色掺比0-255.最后一个为透明的，0-1。 浏览器默认给body加了一个8px的外边距 ul、ol列表默认也有边距 li默认有缩进 盒子的实际大小：自身高度+内边距+边框 盒子的占位空间：自身高度+内边距+边框+外边距 群组选择器：a,div, .box, .top{样式} 通配符选择器：全局选中！*{} 配置方便但是影响性能！（页面渲染时要遍历所有标签，大型网站开发不用） 类选择器：class 后代选择器：#box p display显示1.block块级元素！独占一行，可设置宽高。没有设置宽高时，继承父级宽高。可容纳其他块级元素和行内元素。 常见块级元素： address - 地址blockquote - 块引用center - 举中对齐块dir - 目录列表div - 常用块级容易，也是css layout的主要标签dl - 定义列表fieldset - form控制组form - 交互表单h1 - 大标题h2 - 副标题h3 - 3级标题h4 - 4级标题h5 - 5级标题h6 - 6级标题hr - 水平分隔线isindex - input promptmenu - 菜单列表noframes - frames可选内容（对于不支持frame的浏览器显示此区块内容）noscript - 可选脚本内容（对于不支持script的浏览器显示此内容）ol - 排序列表p - 段落pre - 格式化文本table - 表格ul - 非排序列表 2.inline内联元素！不可设置宽高可与其他元素同处一行只能容纳内联元素不支持设置上下内、外边距，可设置左右内、外边距。内联元素间有空格，就像文字间隙！ 如上，设置内边距时，元素内容位置不变，内边距会上下撑开，从而覆盖在其他元素上。 常见内联元素： a - 锚点abbr - 缩写acronym - 首字b - 粗体（不推荐）bdo - bidi overridebig - 大字体br - 换行cite - 引用code - 计算机代码（在引用源码的时候需要）dfn - 定义字段em - 强调font - 字体设定（不推荐）i - 斜体img - 图片input - 输入框kbd - 定义键盘文本label - 表格标签q - 短引用s - 中划线（不推荐）samp - 定义范例计算机代码select - 项目选择small - 小字体文本span - 常用内联容器，定义文本内区块strike - 中划线strong - 粗体强调sub - 下标sup - 上标textarea - 多行文本输入框tt - 电传文本u - 下划线var - 定义变量 ★★★★其中：img较为特殊。img元素作为替换元素，有着类似于Inline-block的行为！ 可以设置width/height; 默认的，img元素在屏幕占据的空间与其图片的实际像素一致 如果img标签的包裹元素为也为inline元素，则img的边界可以超出其直接父元素的边界，直到自己的宽、高达到最大或者设定值为止，而且文档流中img的兄弟元素也不能遮盖住img。最常见的就是&lt;a&gt;里面包含的&lt;img&gt; 可以通过text-alin：center实现居中！ 3.inline-block行内块级元素兼具块级元素与内联元素的特性 行内块级元素特性：※ margin：0 auto只对块级元素有效！且IE6、IE7不支持！※ text-align文字对齐方式1.left2.center3.right※行内块级元素作为文字解析，因此可以通过text-align：center来实现居中对齐。 外边距合并：当块级元素的外边距相遇时会发生合并，合并后的共同外边距以较大者为准。1.同级块级元素合并：合并后以较大者作为两者间距！2.父子块级元素合并：合并后以较大者作为此方向公共外边距。 解决边距合并方法：改变元素类型，使其不为块级元素。或者在元素间插入文字等其他元素。 ★★★★ p标签不能包p标签和块级元素。 a标签不能包a标签。可以包裹其它。 但是a标签无法完美包裹行内块级元素和块级元素，但是页面中常用这种包裹。因为这样做可以使整个div都可以点击访问，用户体验较好。 ★★★★ 垂直对齐方式vertical-align 只对行内或者行内块有效！ 基线表示： 行内元素和行内块元素对齐方式！1.行内块没有文字的时候，块底端默认以父级的基线（baseline）对齐！ 2.行内块有文字的时候，默认块的基线与父元素的基线对齐。 其他对齐方式： top 元素的顶端与父元素行高（不是高度）的顶端对齐 bottom 元素的底端与父元素行高底端对齐 middle 元素的中线与父元素行高中线对齐 text-top元素的顶端与父元素中文字顶线对齐 text-bottom元素的底端与父元素中文字底线对齐 文字对齐受行高影响，不受父元素盒子大小影响，行高若超过父盒子大小，内容则会溢出。 行高有继承效果！ HTML5 规范声明：应该使用 &lt;h1&gt; - &lt;h6&gt; 来表示标题，使用 &lt;em&gt; 标签来表示强调的文本，应该使用 &lt;strong&gt; 标签来表示重要文本，应该使用 &lt;mark&gt; 标签来表示标注的/突出显示的文本。 2017.11.16 鼠标指针 cursor 鼠标样式指针 pointer 手型 move 可移动指针 text 光标指示文本 wait 加载中 help 帮助 自定义指针 cursor：url（图片路径），pointer 透明度 opacity：整个盒子（包括其子元素）透明度变化 0-1。 background-color：rgb（255,0,0,0.5：最后一项只控制背景颜色的透明度。 rgb是css3的属性，IE一般不兼容 background-color在低版本的IE中不兼容 伪类选择器 .box：hover 2017.11.17 字体 font-family字体样式，包括微软雅黑，宋体，楷体等常见字体群 font-size字体大小 PS:一般浏览器默认样式为16px，火狐浏览器支持12px以下的字体大小，其他浏览器不支持12px以下的字体大小。 em做文字大小单位时，以父元素的文字大小为参考基准单位。 em做宽高时，以当前元素的字体大小做基准。 eg：浏览器默认字体大小16px，font-size：2em则字体大小为32px。width：10em则元素宽度为320px。 rem：以根标签html的字体大小作为基准。多用于移动端！ font-weight 字体粗细 取值：100-900或者normal、bold font-style字体风格。 italic字体倾斜 oblique强制倾斜 normal正常显示 ★★ font-wariant字体大小写 small-caps小写字母大写。 ★★★★ font的所有属性都会被继承 复合样式： ★★★★ text 文本 text-transform本文字母大小写 uppercase小写字母大写 lowercase大写字母小写 capitalize单词首字母大写 text-align文本水平对齐方式 right left center 行内元素无法使用！ text-indent文本段落缩进 px em 行内元素无法使用！ text-decoration本文修饰方式 underline下划线 line-through删除线 overline letter-spacing字符间距 单位：px word-spacing单词间距 单位：px white-space换行方式1. `normal`默认方式 2. `nowrap`不换行 word-breakcss3中换行方式 1. `normal`默认方式 2. `break-all`空间不足时，会拆分完整单词来换行。 3. `keep-all`空间不足，不会拆分单词，而是将其整体换到下一行。 4. `行内元素无法使用！` text-overflow文本超出设置 1. `clip` 文本超出 2. `ellipsis` 文本超出省略处理 3. 配合`overflow：hidden`使用，且`行内元素无法使用！` 特殊字符 浏览器会将多个空格当做一个空格处理。 &amp;nbsp； 空格占位符，一个代表一个空格。 &amp;lt；小于符号 &amp;gt；大于符号 &amp;copy；版权符号 reg； 注册商标 2017.11.18 ####高级选择器及a伪类 一、初级选择器 后代选择器 群组选择器★★★★ 子元素选择器：如div &gt; p直系父子才行。★★★★ 兄弟选择器：如：div + div 表示div的兄弟div元素。样式只加给相邻的兄弟，兄弟间不能有任何其他标签！且样式对元素自身无效，即自身不变！！！ 。 ★★★★一、属性选择器：元素拥有的任何属性（包括自定义属性）都可以作为选择的依据。 1. 如： `[class]`表示选中有class属性的元素 或[class=&quot;text&quot;]表示选中有class属性，且属性值唯一为text的元素。或[class=&quot;text-top&quot;]表示选中有class属性，且值唯一为text-top的元素。总结：可以灵活限定选择范围。 2. 如：`class ~=&quot;nav&quot;` ，表示选中具备`class属性`，且有一个（可有多个）为`nav`的值的元素。 3. 如：`[class |=&quot;nav&quot;]`,表示选中具备class属性，且有以nav或者nav-开头的值的元素。 4. **组合使用**：如 - `[href][titile=&quot;name&quot;]`表示选中具有href属性，且title属性值唯一为name的元素。 二、伪类选择器 a:hover鼠标悬停触发事件 a：link匹配所有没有被点击过的链接 a：visited匹配所有被点击过的链接 a：active匹配正在点击触发的链接 同理其他元素也可以应用以上伪类 ★★当a:hover和a：active同时存在的时候，顺序不能颠倒，否则active样式不生效。 三、伪元素选择器 p：after添加新元素到目标元素后面，默认生成的是行内元素。如：123456789101112131415元素！&lt;body&gt; &lt;p&gt;原来&lt;/p&gt;&lt;/body&gt;样式！&lt;style&gt;p&#123; font-size:30px; background-color: orange;&#125;p:after&#123; content:&quot;新增&quot;&#125;&lt;/style&gt; 结果如图： p：before添加新元素到目标元素前面，默认是行内元素。 ####四、应用和优先级讨论 单个选择器优先级 ID选择器&gt;类选择器&gt;标签选择器&gt;通配符选择器 组合选择器优先级计算★★★★ 我们把CSS的特殊性分为4个等级，每个等级代表一类选择器。每个等级的值为其所代表的选择器的个数乘以这一等级的权值，最后把所有等级的值相加得出选择器的特殊值。 4个等级的定义如下： 第一等：代表内联样式，如: style=””，权值为1000。 第二等：代表ID选择器，如：#content，权值为100。 第三等：代表类，伪类和属性选择器，如.content，权值为10。 第四等：代表类型选择器和伪元素选择器，如div p，权值为1。权重一样时后者覆盖前者 2017.11.20 ####样式优先级行内样式&gt;内部样式&gt;外部引入样式 !important强行提升重要性至最高 1@import url(&quot;相对路径&quot;)，需要顶格写在style中，只能引入CSS文件。引入顺序： link引入的css会在页面加载时同步加载。 import引入的css在页面加载完才能加载。####css3 圆角border-radius 四个值时，分别对应四个角； 三个值时，分别表示左上，右上左下，右下； 两个值时，分别表示左上右下，右上左下； 一个值时，表示四个角 实现圆形 阴影box-shadow 有五类值 阴影可以堆叠★★★★ overflow：hidden溢出隐藏 overflow-y：hidden单方向溢出隐藏 2017.11.21 ####浮动float★★★★ 浮动元素会脱离文档流，不占空间；默认会覆盖在普通DOM元素上。 浮动会造成父级的盒子塌陷 浮动最初运用是为了实现文字环绕 浮动会挤压文本格式的内容（包括文字，行内元素，行内块级元素） 父级规定宽高之后，尽管浮动脱离了文档流，但内容不够依旧会掉下去。 浮动只会在父元素内部浮动，不会脱离父级限定的宽高范围。 浮动会让元素变为块级元素。 浮动排列原则： 后一个只会被紧挨的前一个影响，空间够则紧挨排列在后，不够空间，会以前一个盒子的高度为基准换到下一行。 红色盒子卡住了黑色盒子，在空间不够时，会掉到下一行，但不会填补空缺，而是以红色盒子高度为基准。 对比可知，浮动排列规则。 ★★★★★ ####清除浮动：清除浮动造成的父级元素塌陷 clear，三个值:left,right,both. 一般是通过创建一个新的同级的元素盒子，给他的css添加clear属性，来清除它前面同级元素的浮动。 伪元素法：通过after添加的dom元素，不在页面dom树种，是主流的清除浮动方法，原理同第一种。 具体实现方法如图： ★★★★★ ####最小宽度和最大宽度 min-width:用像素设定大小时，常限定最小宽度，防止盒子变形。 此时，浏览器窗口继续变小之后，元素不会变形。即小于这个宽度后，盒子不会再被挤压变小，而是被遮盖。 max-width:百分比设定大小时，常限定最大宽度，防止盒子变形。 -此时，浏览器窗口继续变大后，元素盒子不会再拉长。即大于这个宽度后，盒子宽度不再增加。####定位 position定位 static默认，没变化 relative相对定位- 相对定位半脱离文档流，相对原来位置移动，子元素也会随着元素一起移动。 - 但是不会造成盒子塌陷，即在父级中原来的空间占位不会消失。 - 相对定位不会改变元素类型 absolute绝对定位- 绝对定位完全脱离文档流，相对有定位属性的父级元素移动，如果没有，则参考body移动。 - 会造成盒子塌陷，在父级中的空间占位消失。 - 绝对定位会改变元素类型为**块级** - `margin：auto`失效 fixed固定定位 相对浏览器窗口定位，不会移动 z-index层级 绝对定位层级&gt;相对定位（给出位移值的）层级&gt;浮动元素层级&gt;普通元素层级（没给位移值的相对定位层级） 默认层级都是0 层级都是相对的，在父级内部，同级元素进行比较。 不同级（辈分）的元素不能比较层级。 2017.11.23 ####表单form action属性：标识表单提交的地址。 method属性，表单数据的提交方式。 get方法 post方法 input元素：输入框。 type类型属性： text （文本框） ，password（密码框），radio（单选框），checkbox（复选框），button（普通按钮），file（文件上传）可限定文件类型！！- 复选框![Alt text](./1511432806144.png) - 复选框中加上`checked`表示默认选中，`disabled`禁制使用。 - 普通按钮![Alt text](./1511432786801.png) - 重置按钮![Alt text](./1511432902424.png) - 提交按钮![Alt text](./1511433177191.png) - 提交数据包括：name属性的关键字和value属性的值，两者组成的键值对。 lable绑定文本到目标ID的选择框上。可实现文字点击选中效果！- ![Alt text](./1511432600393.png) placeholder框内提示信息 selection下拉选框 option下拉选项。加上selected则表示此项默认选中。 textarea文本区域 fieldset组合表单控件，是块级元素。 legend此表单区块的标题 PS：outline：none去掉默认的焦点元素框，默认是蓝色。 ####focus伪类，常用于表单元素 如： ####表格table 表格的一般组成包括thead，tbody，tfoot； 表格具备对齐属性：即改变某一行或者某一列甚至某个格子时，其他元素会行列对齐次。 table的border属性只对最外层加边框。 单元格合并 colspan=？不同列合并，值表示合并的个数，多的单元格会被挤压。 rowspan=？不同行合并，值表示合并的个数，多的单元格会被挤压。 单元格默认类型为table-cell，td，tr，th不支持margin属性，且有默认的padding=1。 边框间距border-spacing：加给table标签，可以控制边框距离，默认两个值，分别控制x，y。 边框合并border-collapse：collapse 2017.11.24 ####iframe框架iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。 通过对a标签的target属性绑定iframe的name值，可实现链接跳转的绑定，及对应显示。即点击a标签对应文字，框架内可显示京东的首页！ ####css继承总结 默认继承的有：color、font、text-align、text-indent、letter-spacing、word-spacing、list-style a标签的颜色值不继承父级的color，有自己的默认颜色。 可以使用inherit来明确继承父级相应的属性值。####css重用通过给元素添加具有固定样式的类，达到样式的高效重复使用的目的。★★★★★选项卡图标！！！ 用法如下：####css书写顺序 第一位：关乎元素类型的 display positon float第二位：元素自身的特性属性 width height border margin padding第三位：其他属性 text font background第四位：css3的属性 ####浏览器前缀谷歌：-webkit-火狐：-moz-欧朋：-o-IE：-ms- ####swiper轮播插件 ####阿里图标是一种字体图标，不会因为放大缩小而模糊。一、单色图标兼容IE8+以上所有现代浏览器。不支持彩色图标！但可以通过CSS进行后期修改。通过引入css文件，给i标签加特定的类名实现二、多色图标性能较差，兼容性较差，不推荐使用。通过引入JS文件，些svg代码块实现 @(培训)[标签1, 标签2, 标签3]]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS作用域详解]]></title>
    <url>%2F2017%2F10%2F22%2FJS%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、涉及概念、知识点1.执行环境 执行环境定义了变量或者函数有权访问的其他数据，执行环境有与之相关联的变量对象。 执行环境会在环境内所有代码执行完毕后，销毁该环境。（全局执行环境会等到应用程序退出或者浏览器窗口关闭才会销毁） 全局执行环境全局执行环境也即window对象，因此所有的全局变量、函数都是window对象的属性和方法。 局部执行环境（函数执行环境）当执行流进入一个函数时，执行环境变为这一特定函数的局部执行环境。待函数执行完后，栈将环境弹出，转而进入下一个执行环境。 正由于不同执行环境间的切换，因此产生了变量和函数的作用域 2.作用域 作用域代表变量与函数的可访问范围，可以说作用域控制着变量与函数的可见性和生命周期。 在JavaScript中，变量的作用域有全局作用域和局部作用域两种，局部作用域又称为函数作用域。全局作用域 拥有全局作用域的对象：1.程序最外层定义的函数或者变量123456789101112var a = &quot;tsrot&quot;;function hello()&#123; alert(a);&#125;function sayHello()&#123; hello();&#125;alert(a); //能访问到tsrothello(); //能访问到tsrotsayHello(); //能访问到hello函数，然后也能访问到tsrot 2.所有末定义直接赋值的变量（不推荐）1234567function hello()&#123; a = &quot;tsrot&quot;; var b = &quot;hello tsrot&quot;;&#125;alert(a); //能访问到tsrotalert(b); //error 不能访问 3.所有window对象的属性和方法如window.name、window.location、window.top等等。 局部作用域（函数作用域）局部作用域在函数内创建，在函数内可访问，函数外不可访问。1234567function hello()&#123; var a = &quot;tsrot&quot;; alert(a);&#125;hello(); //函数内可访问到tsrotalert(a); //error not defined 3.作用域链▷作用域链的用途：保证该执行环境下有权访问的所有变量、函数的有序访问！ ▷作用域链搜索方法：目标标识符的解析是从执行环境的最前端开始，沿着作用域链一级一级向后回溯，直到找到标识符为止。 12345678910111213var color = "blue";function changeColor()&#123; if(color=="blue")&#123; color = "red"; &#125; else&#123; color = "blue"; &#125; &#125; changeColor();console.log(color); //red 以上代码解释了标识符color的搜索过程。在调用函数changeColor（）后，执行到if判定时需要用到变量color。于是在当前执行环境下先于函数内部作用域搜索变量color；未找到后向外层检索，此时访问到了全局变量color=&quot;blue&quot;，if判定符合条件，执行颜色修改为red。 ▷作用域链访问不可逆。整个搜索访问的过程中，可以通过作用域链从内部环境访问外部环境，但不可逆转，是线性有向的过程。12345678910111213141516var color = "blue";function changeColor()&#123; var anotherColor = "red"; function swapColor()&#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; //这里可以访问color、anotherColor和tempColor &#125; //这里可以访问color和anotherColor &#125;//这里只能访问colorchangeColor(); 以上代码中，全局环境、changgeColor()和swapColor()为三个不同的执行环境，可以由内层向外层搜索访问，但不可向内层访问。 ★JavaScript没有块级作用域 JavaScript与其它语言不同的一点是，没有块级作用域。块级作用域：由花括号封闭的代码块都有自己的作封闭执行环境（作用域）。 JavaScript中只有函数具有类似块级作用域的函数作用域。其它if、for、while等具有花括号的语句则没有块级作用域，也即语句执行结束后，内部变量、函数仍可以在外层执行环境中访问到！ 123456789101112131415161718for (var i;i&lt;10;i++) &#123; ------for示例 dosomething(i);&#125;alert(i); //10//依旧可以访问iif(true)&#123; ------if示例 var color = &quot;blue&quot;;&#125;alert(color); //&quot;blue&quot;//同样可以访问到colorfunction add(a,b)&#123; ------function示例 var sum = a+b; return sum;&#125;var result = add(10,20);alert(sum); //error:sum is not defined 二、作用域习题测试1.纯作用域、作用域链类1.123456789101112131415var x = 10; function foo() &#123; var y = 20; function bar() &#123; var z = 30; console.log(x + y + z); &#125;; bar()&#125;; foo(); 代码的输出结果为”60″。函数bar可以直接访问”z”，然后又通过作用域链访问上层的”x”和”y”。 2.12345678var y = &apos;global&apos;; function test(x)&#123; if(x)&#123; var y =&apos;local&apos;; &#125; return y; &#125; console.log(test(true)); //local 在当前作用域（test（）函数）内，可以找到目标标识符y，因此不需要向上访问全局变量y=“global”。 3.12345678910var y = &apos;global&apos;; function test(x)&#123; (function()&#123; if(x)&#123; var y = &apos;local&apos;; &#125; &#125;)(); return y; &#125; console.log(test(true)); //global 在当前作用域（test（）函数）内，找不到标识符y，因此按照向上搜索的规则，沿着作用域链访问全局变量y=“global”。★不能向内层访问自执行函数中的y 4.★★★★函数嵌套类123456789var a=10; function aaa()&#123; alert(a);&#125;; function bbb()&#123;var a=20;aaa();&#125;bbb(); //10 因为bbb（）访问不了内层作用域的变量a，因此向上访问全局变量a = 10.我们一步步来分析这个过程：先看个简单的：若果aaa本身就有，肯定拿自己的。12345678910111213var a = 10;function aaa() &#123; //step-4 var a=30; alert(a); //step-5-&gt;执行alert，此时最先找到aaa作用域下的a=30&#125;; function bbb() &#123; //step-2 var a = 20; aaa(); //step-3&#125;//定义了函数没啥用，调用才是真格的所以这里是step-1bbb(); //30 //step-1 假如aaa（）内未定义a呢，会取谁？ 123456789101112var a = 10;function aaa() &#123; //step-4 alert(a); //step-5-&gt;执行alert，此时最先找到aaa的父作用域中的a=10&#125;; function bbb() &#123; //step-2 var a = 20; aaa(); //step-3&#125;//定义了函数没啥用，调用才是真格的所以这里是step-1bbb(); //10 //step-1 要是全局的var a=10都没有呢？ 12345678910function aaa() &#123; //step-4 alert(a); //step-5-&gt;执行alert，此时沿着作用域一层一层找，没有a，所以报错。&#125;; function bbb() &#123; //step-2 var a = 20; aaa(); //step-3&#125;//定义了函数没啥用，调用才是真格的所以这里是step-1bbb(); //10 //step-1 ★★注意： 函数作用域的嵌套关系是定义时决定的,而不是调用时决定的,也就是说,JavaScript 的作用域是静态作用域,又叫词法作用域,这是因为作用域的嵌套关系可以在语法分析时确定,而不必等到运行时确定。具体可参看这篇文章 放在我们上面的实例中理解就是：aaa和bbb函数作用域是兄弟作用域，互相不能访问内部变量，这在定义的时候就确定了。虽然调用的时候，aaa是在bbb函数的内部调用，但是作用域链却不会被改变！★5. a=b=10类特殊情况123456function aaa()&#123; var a=b=10; &#125; aaa(); alert(a);//结果为,无法访问到 alert(b);//结果为10； var a=b=10; 可以解析成 b=10；var a=b; 也就是b为全局变量，a为局部变量，所以外部访问a访问不到，访问b结果为10； 2.作用域+变量(函数)提升类（笔试面试最爱！）1.1234567891011var y = &apos;global&apos;; function test(x)&#123; console.log(y); //undefined if(x)&#123; var y = &apos;local&apos;; &#125; return y; &#125; console.log(test(true)); //local 这里涉及到JavaScript中的变量提升，JavaScript中会自动把变量声明的语句提升到当前作用域的最前方 。以上代码可以这样来理解 12345678910var y = &apos;global&apos;; function test(x)&#123; var y; //声明提前了 console.log(y); if(x)&#123; y = &apos;local&apos;; //赋值仍留着原地 &#125; return y; &#125; console.log(test(true)); //local 当test函数中打印y时，变量y只是被声明了，并没有赋值，所以先打印出了undefined；当程序继续向下执行，则将local返回出来。2.123456789var a = 1; function b()&#123; a = 10; console.log(a); //10 return; var a = 100; &#125; b(); console.log(a); // 1 变量a先是全局声明，在调用b()函数时，在内部又声明了局部的a变量（因为var a=100变量提升），改变其值为10.在执行完毕后，退出函数环境，局部的a变量销毁，因此访问到的a为全局的1。4.123456789var a = 100; function testResult()&#123; var b = 2 * a; var a = 200; var c = a / 2; alert(b); alert(c); &#125; testResult() //NaN 100 同样是基于变量声明提前，原理参考第1题过程。局部变量a在函数中声明提前到第一行，值为undefined。因此b值为NaN,在a赋值后，c值为100。 5.1234567var getName = function()&#123; console.log(2);&#125;function getName ()&#123; console.log(1);&#125;getName(); 这个例子同时涉及到了变量声明提升和函数声明提升。上例等同于：12345678var getName; //变量声明提升function getName()&#123; //函数声明提升到顶部 console.log(1);&#125;getName = function()&#123; //变量赋值依然保留在原来的位置 console.log(2);&#125;getName(); // 最终输出：2 由于变量和函数声明均提升到顶部，因此getName又被后面函数表达式的赋值操作给覆盖了，所以输出2而如果将上代码稍加改动，变这样的话：1234567getName(); //最终输出：1var getName = function()&#123; console.log(2);&#125;function getName ()&#123; console.log(1);&#125; 等同于： 123456789var getName; //变量声明提升function getName()&#123; //函数声明提升到顶部 console.log(1);&#125;getName(); // 最终输出：1getName = function()&#123; //变量赋值依然保留在原来的位置 console.log(2);&#125; 看到这里，有些人可能会觉得，当存在两个相同的声明，是不是由于覆盖的现象？造成了上面的结果？那么接下来我们研究一下，到底两者共存遵循什么规律。比如，有下述代码：1234567891011var a = funtion () &#123; console.log(10)&#125;var a;console.log(a); // f a() &#123;console.log(10)&#125;console.log(a()); // 10 和 undefineda = 3;console.log(a) //3a = 6;console.log(a()); //a() is not a function; 从结果我们可以看到：首先变量a提升到顶部，然后给它赋值一个函数，此时打印a，a为函数。后面进行了赋值3操作后，a变为3，此时再执行a（），浏览器会提示我们出错了。也就是说此时a又被覆盖为一个变量，而非函数。a的变化过程如下：1234567var a; //变量提升a=undefineda = function ()&#123; console.log(10); //a赋值一个函数&#125;a = 3; //a赋值一个变量a = 6; 总结：1.同时出现变量提升和函数提升时，函数会首先被提升，然后才是变量。2.函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。详细内容可以参看：书籍《你不知道的JavaScript》 三、延长、扩展作用域1.延长作用域链 实现原理：在作用域链的前端增加一个变量对象，当执行流进入下列语句时，作用域链就得到加长： try-catch语句的catch块 with语句 1.对于with语句来说，会将指定的对象添加到作用域链中。2.对于catch语句来说，会创建一个新的变量对象。 例：123456789function alterUrl() &#123; var qs = &quot;?debug=true&quot;; with(location) &#123; var url = href + qs; &#125; return url;&#125; with语句接收location对象，等同于with语句的作用域链扩展添加了location对象作用域部分。因此，在with语句中可以调用所有的location对象的属性和方法。此时的href默认将获取浏览器的href，无需赋值。 2.扩展作用域扩展作用域的方法常用有两种： call（）方法 apply（）方法 PS: call和apply方法是函数本身具有的非继承的方法，不仅可以传递参数，还可以扩充函数运行的作用域。 ★apply（）方法能劫持另外一个对象的方法，继承另外一个对象的属性. Function.apply(obj,args)`方法接收两个参数： **obj：**这个对象将代替Function类里this对象 **args：**这个是数组，可以是Array，也可以是arguments对象。总之它将作为参数传给 Function（args--&gt;arguments） ★ call:和apply的意思一样,只不过是将参数数组改为了参数列表. Function.call(obj,[param1[,param2[,…[,paramN]]]]) **obj：**这个对象将代替Function类里this对象. **params：**这个是一个参数列表. 示例：1.call():（1）不传递参数，只改变this指向，以扩充作用域。12345678910111213window.color = &apos;red&apos;; document.color = &apos;yellow&apos;; var s1 = &#123;color: &apos;blue&apos; &#125;; function changeColor()&#123; console.log(this.color); &#125; changeColor.call(); //red (默认传递参数为window对象参数) changeColor.call(window); //red changeColor.call(document); //yellow changeColor.call(this); //red changeColor.call(s1); //blue ★（2）call的参数列表必须一一对应，否则将会出现赋值交叉。 123456789101112function food(name,price)&#123; this.name = name; this.price = price;&#125;function fruits(name,price,weight)&#123; food.call(this,name,price,weight); this.weight = weight;&#125;var result = new fruits(&quot;pingguo&quot;,5,2)alert(result.name+&quot;--&quot;+result.price+&quot;--&quot;+result.weight); //pingguo--5--2 以上代码参数列表与food的变量顺序是保持一致。如果将参数列表顺序打乱(或者food函数参数顺序打乱)，就会出现赋值交叉的情况，如：123456789101112function food(name,price)&#123; this.name = name; this.price = price;&#125;function fruits(name,price,weight)&#123; food.call(this,price,name,weight); this.weight = weight;&#125;var result = new fruits(&quot;pingguo&quot;,5,2)alert(result.name+&quot;--&quot;+result.price+&quot;--&quot;+result.weight); //5--pingguo--2 2.apply():（1）不传递参数，只改变this指向，扩展作用域123456789101112window.number = &apos;one&apos;;document.number = &apos;two&apos;;var s1 = &#123;number: &apos;three&apos; &#125;;function changeColor()&#123; console.log(this.number);&#125;changeColor.apply(); //one (默认传参为window对象下参数)changeColor.apply(window); //onechangeColor.apply(document); //twochangeColor.apply(this); //onechangeColor.apply(s1); //three （2）函数间作用域扩展，实现方法调用。12345678910111213function Person(name,age)&#123; //定义一个人类 this.name = name; this.age = age;&#125;function Student(name,age,grade)&#123; //定义一个学生类 Person.apply(this,arguments); //扩展Student的作用域到Person。 //或者Person.call(this,name,age); 也可实现作用域扩展！ this.grade = grade;&#125;var student1 = new Student(&quot;xiaowang&quot;,21,90);alert(student1.name+student1.age+student1.grade); //xiaowang2190 详细的扩展作用域的方法解析，可以参看这篇文章：call，apply，bind改变this指向 参考文章书籍：JavaScript高级程序设计-第四章深入了解JavaScript，从作用域链开始（1） JS作用域面试题总结]]></content>
      <categories>
        <category>JS作用域详解</category>
      </categories>
      <tags>
        <tag>JS作用域详解</tag>
      </tags>
  </entry>
</search>
